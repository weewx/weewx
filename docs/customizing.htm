<!DOCTYPE html>
<html lang="en">
<head>
    <title>WeeWX: Customization Guide</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="icon" href="images/favicon.png" type="image/png"/>
    <link rel="stylesheet" href="css/tocbot-4.12.0.css">
    <link rel="stylesheet" href="css/weewx_ui.css"/>
    <script src="js/cash.min.js"></script>
    <script src="js/tocbot-4.12.0.min.js"></script>
    <script src="js/weewx.js"></script>
    <script>
        $(function () {
            make_ids('#technical_content');
            let level = get_level_from_cookie();
            create_toc_level_control(level);
            create_toc(level);
        })
    </script>
</head>

<body>

<div class="sidebar">
    <div class="doclist">
        <a href="usersguide.htm">User's Guide</a><br/> <a href="customizing.htm">Customization Guide</a><br/> <a
        href="hardware.htm">Hardware Guide</a><br/> <a href="utilities.htm">Utilities Guide</a><br/> <a
        href="upgrading.htm">Upgrade Guide</a><br/> <a href="devnotes.htm">Notes for Developers</a>
    </div>
    <div id="toc_controls">
        <!-- The TOC select list will be injected here -->
    </div>
    <div id="toc_parent">
        <div id="toc-location" class="toc">
            <!-- The table of contents will be injected here -->
        </div>
    </div>
</div>

<div class="main">

    <div class="header">
        <div class="logoref">
            <a href='https://weewx.com'> <img src='images/logo-weewx.png' class='logo' style="float:right"
                                             alt="weewx logo"/> </a><br/> <span class='version'>
Version: 4.9
    </span>
        </div>
        <div class="title">WeeWX Customization Guide</div>
    </div>

    <div id="technical_content" class="content">

        <p>
            This document covers the customization of WeeWX. It assumes that you have read, and are
            reasonably familiar with, the <a href="usersguide.htm">Users Guide</a>.
        </p>
        <p>
            The introduction contains an overview of the architecture. If you are only interested
            in customizing the generated reports you can probably skip the introduction and proceed
            directly to the section <a href="#customizing_reports"><em>Customizing reports</em></a>.
            With this approach you can easily add new plot images, change the titles of images,
            change the units used in the reports, and so on.
        </p>

        <p>
            However, if your goal is a specialized application, such as adding alarms, RSS feeds,
            <i>etc.</i>, then it would be worth your while to read about the internal architecture.
        </p>

        <p>
            Most of the guide applies to any hardware, but the exact data types are
            hardware-specific. See the <a href="hardware.htm"><em>WeeWX Hardware Guide</em></a>
            for details of how different observation types are handled by different types hardware.
        </p>

        <p class="warning">
            <strong>Warning!</strong><br/> WeeWX is still an experimental system and, as such,
            its internal design is subject to change. Future upgrades may break any customizations
            you have done, particularly if they involve the API (skin customizations tend to be
            more stable).
        </p>


        <!-- -------------------------------------------------------------- -->

        <h1 id="introduction">Introduction</h1>

        <h2>Overall system architecture</h2>

        <p>
            Below is a brief overview of the WeeWX system architecture, which is covered in much
            more detail in the rest of this document.
        </p>

        <div class="image image-right" style="width: 30%">
            <img src="images/pipeline.png" alt="The WeeWX pipeline"/>

            <div class="image_caption">A typical WeeWX pipeline. The actual pipeline depends
                on what extensions are in use. Data, in the form of LOOP packets and archive
                records, flows from top to bottom.</div>
        </div>
        <ul>
            <li>
                A WeeWX process normally handles the monitoring of one station &mdash; <i>e.g.</i> a
                weather station. The process is configured using options in a configuration file, typically called 
                <span class="code">weewx.conf</span>.
            </li>

            <li>
                A WeeWX process has at most one "driver" to communicate with the station hardware
                and receive "high resolution" (<i>i.e.</i> every few seconds) measurement data in
                the form of LOOP packets. The driver is single-threaded and blocking, so no more
                than one driver can run in a WeeWX process.
            </li>


            <li>
                LOOP packets may contain arbitrary data from the station/driver in the form of a
                Python dictionary. Each LOOP packet must contain a time stamp, and a unit system,
                in addition to any number of observations, such as temperature or humidity.
                For extensive types, such as rain, the packet contains the total amount of
                rain that fell during the observation period.
            </li>
            <li>
                WeeWX then compiles these LOOP packets into regularly spaced "archive records."
                For most types, the archive record contains the average value seen in all of the
                LOOP packets over the archive interval (typically 5 minutes). For extensive types,
                such as rain, it is the sum of all values over the archive interval.
            </li>
            <li>
                Internally, the WeeWX engine uses a <em>pipeline</em> architecture, consisting
                of many <em>services</em>. Services bind to events of interest, such as new
                LOOP packets, or new archive records. Events are then run down the pipeline
                in order &mdash; services at the top of the pipeline act on the data
                before services farther down the pipe.
            </li>

            <li>
                Services can do things such as check the data quality, apply corrections, or save
                data to a database. Users can easily add new services.
            </li>

            <li>
                WeeWX includes an ability to customize behavior by installing <em>extensions</em>.
                Extensions may consist of one or more drivers, services, and/or skins, all in an
                easy-to-install package.
            </li>
        </ul>


        <h2 id="Data_architecture">Data architecture</h2>

        <p>
            WeeWX is data-driven. When the sensors spit out some data, WeeWX does something. The
            "something" might be to print out the data, or to generate an HTML report, or to use
            FTP to copy a report to a web server, or to perform some calculations using the data.
        </p>

        <p>
            A driver is Python code that communicates with the hardware. The driver reads data from
            a serial port or a device on the USB or a network interface. It handles any decoding of
            raw bits and bytes, and puts the resulting data into LOOP packets. The drivers for
            some kinds of hardware (most notably, Davis Vantage) are capable of emitting archive
            records as well.
        </p>
        <p>
            In addition to the primary observation types such as temperature, humidity, or solar
            radiation, there are also many useful dependent types, such as wind chill, heat index,
            or ET, which are calculated from the primary data. The firmware in some weather
            stations are capable of doing many of these calculations on their own. For the rest,
            should you choose to do so, the WeeWX service <a
            href="usersguide.htm#StdWXCalculate"><span class="code">StdWXCalculate</span></a> can
            fill in the gaps. Sometimes the firmware simply does it wrong, and you may choose to
            have WeeWX do the calculation, despite the type's presence in LOOP packets.
        </p>

        <h2>LOOP packets <em>vs.</em> archive records </h2>

        <p>
            Generally, there are two types of data that flow through WeeWX: LOOP packets, and
            archive records. Both are represented as Python dictionaries.
        </p>

        <h3>LOOP packets</h3>
        <p>
            LOOP packets are the raw data generated by the device driver. They get their name from the Davis Instruments
            documentation. For some devices they are generated at rigid intervals, such as every 2 seconds for the Davis
            Vantage series, for others, irregularly, every 20 or 30 seconds or so. LOOP packets may or may not contain
            all the data types. For example, a packet may contain only temperature data, another only barometric data,
            <em>etc</em>. These kinds of packet are called <em>partial record packets</em>. By contrast, other types of
            hardware (notably the Vantage series), every LOOP packet contains every data type.
        </p>

        <p>In summary, LOOP packets can be highly irregular, but they come in frequently.</p>

        <h3>Archive records</h3>

        <p>
            By contrast, archive records are highly regular. They are generated at regular intervals (generally every 5
            to 30 minutes), and all contain the same data types. They represent an <em>aggregation</em> of the LOOP
            packets over the archive interval. The exact kind of aggregation depends on the data type. For example, for
            temperature, it's generally the average temperature over the interval. For rain, it's the sum of rain over
            the interval. For battery status it's the last value in the interval.
        </p>

        <p>
            Some hardware is capable of generating their own archive records (the Davis Vantage and
            Oregon Scientific WMR200, for example), but for hardware that cannot, WeeWX generates
            them.
        </p>

        <p>It is the archive data that is put in the SQL database, although, occasionally, the LOOP packets can be
            useful (such as for the Weather Underground's "Rapidfire" mode).
        </p>

        <h2>What to customize</h2>

        <p>
            For configuration changes, such as which skins to use, or enabling posts to the
            Weather Underground, simply modify the WeeWX configuration file
            <span class="code">weewx.conf</span>. Any changes you make will be preserved during
            an upgrade.
        </p>
        <p>
            Customization of reports may require changes to a skin configuration file <span
            class="code">skin.conf</span> or template files ending in <span
            class="code">.tmpl</span> or <span class="code">.inc</span>. Anything in the <span
            class="code">skins</span> subdirectory is also preserved across upgrades.
        </p>
        <p>
            You may choose to install one of the many <a
            href="https://github.com/weewx/weewx/wiki#extensions-to-weewx">third-party
            extensions</a> that are available for WeeWX. These are typically installed in either
            the <span class="code">skins</span> or <span class="code">user</span> subdirectories,
            both of which are preserved across upgrades.
        </p>

        <p>
            More advanced customizations may require new Python code or modifications of
            example code. These should be placed in the <span class="code">user</span> directory,
            where they will be preserved across upgrades. For example, if you wish to modify one of
            the examples that comes with WeeWX, copy it from the <span class="code">examples</span>
            directory to the <span class="code">user</span> directory, then modify it there. This
            way, your modifications will not be touched if you upgrade.
        </p>
        <p>
            For code that must run before anything else in WeeWX runs (for example, to set up an
            environment), put it in the file <span class="code">extensions.py</span> in the <span
            class="code">user</span> directory. It is always run before the WeeWX engine starts up.
            Because it is in the <span class="code">user</span> subdirectory, it is preserved
            between upgrades.
        </p>

        <h2>Do I need to restart WeeWX?</h2>
        <p>
            If you make a change in <span class="code">weewx.conf</span>, you will need to restart
            WeeWX.
        </p>
        <p>
            If you modify Python code in the <span class="code">user</span> directory or elsewhere,
            you will need to restart WeeWX.
        </p>
        <p>
            If you install an extension, you will need to restart WeeWX.
        </p>
        <p>
            If you make a change to a template or to a <span class="code">skin.conf</span> file,
            you do not need to restart WeeWX. The change will be adopted at the next reporting
            cycle, typically at the end of an archive interval.
        </p>
        <h2 id="wee_reports">
            The utility <span class="code">wee_reports</span>
        </h2>

        <p>
            If you make changes, how do you know what the results will look like? You could just run WeeWX and wait
            until the next reporting cycle kicks off but, depending on your archive interval, that could be a 30 minute
            wait or more.
        </p>

        <p>
            The utility <span class="code">wee_reports</span> allows you to run a report whenever you like. To use it,
            just run it from a command line, with the location of your configuration file <span
            class="code">weewx.conf</span> as the first argument. Optionally, if you include a unix epoch timestamp as a
            second argument, then the report will use that as the "Current" time; otherwise, the time of the last record
            in the archive database will be used. Here is an example, using 1 May 2014 00:00 PDT as the "Current" time.
        </p>
        <pre class="tty"><span class="cmd">wee_reports weewx.conf 1398927600</span></pre>

        <p>
            For more information about <span class="code">wee_reports</span>, see the <a
            href="utilities.htm#wee_reports_utility">Utilities Guide</a>
        </p>

        <h2>The WeeWX service architecture</h2>

        <p>
            At a high-level, WeeWX consists of an engine class called <span class="code">StdEngine</span>. It is
            responsible for loading <em>services</em>, then arranging for them to be called when key events occur, such
            as the arrival of LOOP or archive data. The default install of WeeWX includes the following services:
        </p>
        <table id='default_services' class="indent">
            <caption>The standard WeeWX services</caption>
            <tbody>
            <tr class="first_row">
                <td>Service</td>
                <td>Function</td>
            </tr>
            <tr>
                <td class="code first_col">weewx.engine.StdTimeSynch</td>
                <td>Arrange to have the clock on the station synchronized at regular intervals.
                </td>
            </tr>
            <tr>
                <td class="code first_col">weewx.engine.StdConvert</td>
                <td>Converts the units of the input to a target unit system (such as US or Metric).
                </td>
            </tr>
            <tr>
                <td class="code first_col">weewx.engine.StdCalibrate</td>
                <td>Adjust new LOOP and archive packets using calibration expressions.
                </td>
            </tr>
            <tr>
                <td class="code first_col">weewx.engine.StdQC</td>
                <td>Check quality of incoming data, making sure values fall within a specified range.
                </td>
            </tr>
            <tr>
                <td class="code first_col">weewx.wxservices.StdWXCalculate</td>
                <td>Calculate any missing, derived weather observation types, such a dewpoint, windchill, or
                    altimeter-corrected pressure.
                </td>
            </tr>
            <tr>
                <td class="code first_col">weewx.engine.StdArchive</td>
                <td>Archive any new data to the SQL databases.</td>
            </tr>
            <tr>
                <td class="code first_col">weewx.restx.StdStationRegistry<br/> weewx.restx.StdWunderground<br/>
                    weewx.restx.StdPWSweather<br/> weewx.restx.StdCWOP<br/> weewx.restx.StdWOW<br/>weewx.restx.StdAWEKAS
                </td>
                <td>Various <a href="https://en.wikipedia.org/wiki/Representational_State_Transfer"> RESTful services</a>
                    (simple stateless client-server protocols), such as the Weather Underground, CWOP, etc. Each
                    launches its own, independent thread, which manages the post.
                </td>
            </tr>
            <tr>
                <td class="code first_col">weewx.engine.StdPrint</td>
                <td>Print out new LOOP and archive packets on the console.
                </td>
            </tr>
            <tr>
                <td class="code first_col">weewx.engine.StdReport</td>
                <td>Launch a new thread to do report processing after a new archive record arrives. Reports do things
                    such as generate HTML or CSV files, generate images, or transfer files using FTP/rsync.
                </td>
            </tr>
            </tbody>
        </table>
        <p>
            It is easy to extend old services or to add new ones. The source distribution includes an example new
            service called <span class="code">MyAlarm</span>, which sends an email when an arbitrary expression
            evaluates <span class="code">True</span>. These advanced topics are covered later in the section <em><a
            href="#service_engine">Customizing the WeeWX service engine</a></em>.
        </p>


        <h2>
            The standard reporting service, <span class="code">StdReport</span>
        </h2>

        <p>
            For the moment, let us focus on the last service, <span class="code">weewx.engine.StdReport</span>, the
            standard service for creating reports. This will be what most users will want to customize, even if it means
            just changing a few options.
        </p>

        <h3>Reports</h3>

        <p>
            The standard reporting service, <span class="code">StdReport</span>, runs zero or more <em>reports</em>. The
            specific reports which get run are set in the configuration file <span class="code">weewx.conf</span>, in
            section <span class="code">[StdReport]</span>.
        </p>

        <p>
            The default distribution of WeeWX includes six reports:
        </p>
        <table class="indent">
            <tbody>
            <tr class="first_row">
                <td>Report</td>
                <td>Default functionality</td>
            </tr>
            <tr>
                <td class="code first_col">SeasonsReport</td>
                <td>Introduced with WeeWX V3.9, this report generates a single HTML file with day, week, month and year
                    "to-date" summaries, as well as the plot images to go along with them. Buttons select which time
                    scale the user wants. It also generates HTML files with more details on celestial bodies and
                    statistics. Also generates NOAA monthly and yearly summaries.
                </td>
            </tr>
            <tr>
                <td class="code first_col">SmartphoneReport</td>
                <td>A simple report that generates an HTML file, which allows "drill down" to show more detail about
                    observations. Suitable for smaller devices, such as smartphones.
                </td>
            </tr>
            <tr>
                <td class="code first_col">MobileReport</td>
                <td>A super simple HTML file that just shows the basics. Suitable for low-powered or
                    bandwidth-constrained devices.
                </td>
            </tr>
            <tr>
                <td class="code first_col">StandardReport</td>
                <td>This is an older report that has been used for many years in WeeWX. It generates day, week, month
                    and year "to-date" summaries in HTML, as well as the plot images to go along with them. Also
                    generates NOAA monthly and yearly summaries. It typically loads faster than the
                    <em>SeasonsReport</em>.
                </td>
            </tr>
            <tr>
                <td class="code first_col">FTP</td>
                <td>Transfer everything in the <span class="symcode">HTML_ROOT</span> directory to a remote server using
                    ftp.
                </td>
            </tr>
            <tr>
                <td class="code first_col">RSYNC</td>
                <td>Transfer everything in the <span class="symcode">HTML_ROOT</span> directory to a remote server using
                    the utility <a href="https://man7.org/linux/man-pages/man1/rsync.1.html">rsync</a>.
                </td>
            </tr>
            </tbody>
        </table>
        <p>Note that the FTP and RSYNC "reports" are a funny kind of report in that it they do not actually generate
            anything. Instead, they use the reporting service engine to transfer files and folders to a remote server.
        </p>

        <h3>Skins</h3>

        <p>
            Each report has a <em>skin</em> associated with it. For most reports, the relationship with the skin is an
            obvious one: the skin contains the templates, any auxiliary files such as background GIFs or CSS style sheets,
            files with localization data, and a <em>skin configuration file</em>, <span class="code">skin.conf</span>.
            If you will, the skin controls the <em>look and feel</em> of the report. Note that more than one report can
            use the same skin. For example, you might want to run a report that uses US Customary units, then run
            another report against the same skin, but using metric units and put the results in a different place. All
            this is possible by either overriding configuration options in the WeeWX configuration file or the skin configuration file.
        </p>

        <p>Like all reports, the FTP and RSYNC "reports" also use a skin, and include a skin configuration file,
            although they are quite minimal.
        </p>

        <p>
            Skins live in their own directory called <span class='code'>skins</span>, whose location is referred to as
            <a href="#skin-root-description"> <span class="symcode">SKIN_ROOT</span></a>.

        </p>
        <div id="skin-root-description" class="modal-dialog">
            <div>
                <!--suppress HtmlUnknownAnchorTarget -->
                <a href="#close" title="Close" class="close-dialog">X</a>
                <h4>SKIN_ROOT</h4>
                <p>
                    The symbol <span class='code'>SKIN_ROOT</span> is a symbolic name to the location of the directory
                    where your skins are located. It is not to be taken literally. Consult the <a
                    href="usersguide.htm#dir-layout-table">directory layout table</a> in the User's Guide for its exact
                    location, dependent on how you installed WeeWX and what operating system you are using
                </p>
            </div>
        </div>

        <h3>Generators</h3>

        <p>
            To create their output, skins rely on one or more <em>generators</em>, which are what do the actual work,
            such as creating HTML files or plot images. Generators can also copy files around or FTP/rsync them to
            remote locations. The default install of WeeWX includes the following generators:
        </p>
        <table class="indent">
            <tbody>
            <tr class="first_row">
                <td>Generator</td>
                <td>Function</td>
            </tr>
            <tr>
                <td class="code first_col">weewx.cheetahgenerator.CheetahGenerator</td>
                <td>Generates files from templates, using the Cheetah template engine. Used to generate HTML and text
                    files.
                </td>
            </tr>
            <tr>
                <td class="code first_col">weewx.imagegenerator.ImageGenerator</td>
                <td>Generates graph plots.</td>
            </tr>
            <tr>
                <td class="code first_col">weewx.reportengine.FtpGenerator</td>
                <td>Uploads data to a remote server using FTP.</td>
            </tr>
            <tr>
                <td class="code first_col">weewx.reportengine.RsyncGenerator</td>
                <td>Uploads data to a remote server using rsync.</td>
            </tr>
            <tr>
                <td class="code first_col">weewx.reportengine.CopyGenerator</td>
                <td>Copies files locally.</td>
            </tr>
            </tbody>
        </table>
        <p>
            Note that the three generators <span class="code">FtpGenerator</span>, <span
            class="code">RsyncGenerator</span>, and <span class="code">CopyGenerator</span> do not actually generate
            anything having to do with the presentation layer. Instead, they just move files around.
        </p>

        <p>
            Which generators are to be run for a given skin is specified in the skin's configuration file <span
            class="code">skin.conf</span>, in section <a href="#generators_section"><span
            class="code">[Generators]</span></a>.
        </p>

        <h3>Templates</h3>

        <p>
            A template is a text file that is processed by a <em>template engine</em> to create a new file. WeeWX uses
            the <a href="https://pythonhosted.org/Cheetah/">Cheetah</a> template engine. The generator <span
            class="code">weewx.cheetahgenerator.CheetahGenerator</span> is responsible for running Cheetah at
            appropriate times.
        </p>

        <p>A template may be used to generate HTML, XML, CSV, Javascript, or any other type of text file. A template
            typically contains variables that are replaced when creating the new file. Templates may also contain simple
            programming logic.
        </p>

        <p>
            Each template file lives in the skin directory of the skin that uses it. By convention, a template file ends
            with the <span class="code">.tmpl</span> extension. There are also template files that end with the <span
            class="code">.inc</span> extension. These templates are included in other templates.
        </p>

        <h2 id="The_database">The database</h2>

        <p>
            WeeWX uses a single database to store and retrieve the records it needs. It can be implemented by using
            either <a href="https://www.sqlite.org/">SQLITE3</a>, an open-source, lightweight SQL database, or <a
            href="https://www.mysql.com/"> MySQL</a>, an open-source, full-featured database server.
        </p>

        <h3>Structure</h3>

        <p>
            Inside this database are several tables. The most important is the <em>archive table</em>, a big flat table,
            holding one record for each archive interval, keyed by <span class="code">dateTime</span>, the time at the
            end of the archive interval. It looks something like this:
        </p>

        <table class="indent fixed_width">
            <caption>
                Structure of the <span class="code">archive</span> database table
            </caption>
            <tr class="code first_row">
                <td>dateTime</td>
                <td>usUnits</td>
                <td>interval</td>
                <td>barometer</td>
                <td>pressure</td>
                <td>altimeter</td>
                <td>inTemp</td>
                <td>outTemp</td>
                <td>...</td>
            </tr>

            <tr class="code">
                <td>1413937800</td>
                <td>1</td>
                <td>5</td>
                <td>29.938</td>
                <td><em>null</em></td>
                <td><em>null</em></td>
                <td>71.2</td>
                <td>56.0</td>
                <td>...</td>
            </tr>
            <tr class="code">
                <td>1413938100</td>
                <td>1</td>
                <td>5</td>
                <td>29.941</td>
                <td><em>null</em></td>
                <td><em>null</em></td>
                <td>71.2</td>
                <td>55.9</td>
                <td>...</td>
            </tr>
            <tr class="code">
                <td>...</td>
                <td>...</td>
                <td>...</td>
                <td>...</td>
                <td>...</td>
                <td>...</td>
                <td>...</td>
                <td>...</td>
                <td>...</td>
            </tr>
        </table>

        <p>
            The first three columns are <em>required.</em> Here's what they mean:
        </p>
        <table class="indent">
            <tr class="first_row">
                <td>Name</td>
                <td>Meaning</td>
            </tr>
            <tr>
                <td class="first_col code">dateTime</td>
                <td>The time at the end of the archive interval in <a href="https://en.wikipedia.org/wiki/Unix_time">unix
                    epoch time</a>. This is the <em>primary key</em> in the database. It must be unique, and it cannot
                    be null.
                </td>
            </tr>
            <tr>
                <td class="first_col code">usUnits</td>
                <td>The unit system the record is in. It cannot be null. See the <em><a href="#units">Appendix:
                    Units</a></em> for how these systems are encoded.
                </td>
            </tr>
            <tr>
                <td class="first_col code">interval</td>
                <td>The length of the archive interval in <em>minutes</em>. It cannot be null.
                </td>
            </tr>
        </table>

        <p>
            In addition to the main archive table, there are a number of smaller tables inside the database, one for
            each observation type, which hold <em>daily summaries</em> of the type, such as the minimum and maximum value
            seen during the day, and at what time. These tables have names such as <span class="code">archive_day_outTemp</span>
            or <span class="code">archive_day_barometer</span>. Their existence is generally transparent to the user.
            For more details, see the section <a href="devnotes.htm#Daily_summaries"><em>Daily
            summaries</em></a> in the document <em>Developer's Notes</em>.
        </p>

        <h3 id="binding_names">Binding names</h3>

        <p>
            While most users will only need the one weather database that comes with WeeWX, the reporting engine allows
            you to use multiple databases in the same report. For example, if you have installed the <a
            href="https://github.com/weewx/weewx/wiki/cmon"><span class="code">cmon</span></a> computer monitoring
            package, which uses its own database, you may want to include some statistics or graphs about your server in
            your reports, using that database.
        </p>

        <p>
            An additional complication is that WeeWX can use more than one database implementation: SQLite or MySQL.
            Making users specify in the templates not only which database to use, but also which implementation, would
            be unreasonable.
        </p>

        <p>
            The solution, like so many other problems in computer science, is to introduce another level of indirection,
            a <em>database binding</em>. Rather than specify which database to use, you specify which <em>binding</em>
            to use. Bindings do not change with the database implementation, so, for example, you know that <span
            class="code">wx_binding</span> will always point to the weather database, no matter if its implementation is
            a sqlite database or a MySQL database. Bindings are listed in section <a href="usersguide.htm#DataBindings"><span
            class="code">[DataBindings]</span></a> in <span class="code">weewx.conf</span>.
        </p>

        <p>
            The standard weather database binding that WeeWX uses is <span class="code">wx_binding</span>. This is the
            binding that you will be using most of the time and, indeed, it is the default. You rarely have to specify
            it explicitly.
        </p>

        <h3>Programming interface</h3>

        <p>
            WeeWX includes a module called <span class='code'>weedb</span> that provides a single interface for many of
            the differences between database implementations such as SQLite and MySQL. However, it is not uncommon to
            make direct SQL queries within services or search list extensions. In such cases, the SQL should be generic
            so that it will work with every type of database.
        </p>

        <p>The database manager class provides methods to create, open, and query a database. These are the canonical
            forms for obtaining a database manager.
        </p>

        <p>If you are opening a database from within a WeeWX service:</p>
        <pre class='tty'>db_manager = self.engine.db_binder.get_manager(data_binding='name_of_binding', initialize=True)

# Sample query:
db_manager.getSql("SELECT SUM(rain) FROM %s "\
    "WHERE dateTime&gt;? AND dateTime&lt;=?" % db_manager.table_name, (start_ts, stop_ts))</pre>
        <p>
            If you are opening a database from within a WeeWX search list extension, you will be passed in a function
            <span class="code">db_lookup()</span> as a parameter, which can be used to bind to a database. By default,
            it returns a manager bound to <span class="code">wx_binding</span>:
        </p>
        <pre class='tty'>wx_manager    = db_lookup()                                    # Get default binding
other_manager = db_lookup(data_binding='some_other_binding')   # Get an explicit binding

# Sample queries:
wx_manager.getSql("SELECT SUM(rain) FROM %s "\
    "WHERE dateTime&gt;? AND dateTime&lt;=?" % wx_manager.table_name, (start_ts, stop_ts))
other_manager.getSql("SELECT SUM(power) FROM %s"\
    "WHERE dateTime&gt;? AND dateTime&lt;=?" % other_manager.table_name, (start_ts, stop_ts))</pre>
        <p>
            If opening a database from somewhere other than a service, and there is no <span
            class="code">DBBinder</span> available:
        </p>
        <pre class='tty'>db_manager = weewx.manager.open_manager_with_config(config_dict, data_binding='name_of_binding')

# Sample query:
db_manager.getSql("SELECT SUM(rain) FROM %s "\
    "WHERE dateTime&gt;? AND dateTime&lt;=?" % db_manager.table_name, (start_ts, stop_ts))</pre>
        <p>
            The <span class="code">DBBinder</span> caches managers, and thus database connections. It cannot be shared
            between threads.
        </p>

        <h2>Units</h2>

        <p>
            The unit architecture in WeeWX is designed to make basic unit conversions and display of units easy. It is
            not designed to provide dimensional analysis, arbitrary conversions, and indications of compatibility.
        </p>

        <p>
            The <em>driver</em> reads observations from an instrument and converts them, as necessary, into a standard
            set of units. The actual units used by each instrument vary widely; some instruments use Metric units,
            others use US Customary units, and many use a mixture. The driver ensures that the units are consistent for
            storage in the WeeWX database. By default, and to maintain compatibility with <span
            class='code'>wview</span>, the default database units are US Customary, although this can be changed.
        </p>

        <p>
            Note that whatever unit system is used in the database, data can be <em>displayed</em> using any unit
            system. So, in practice, it does not matter what unit system is used in the database.
        </p>

        <p>
            Each <em>observation type</em>, such as <span class='code'>outTemp</span> or <span
            class='code'>pressure</span>, is associated with a <em>unit group</em>, such as <span class='code'>group_temperature</span>
            or <span class='code'>group_pressure</span>. Each unit group is associated with a <em>unit type</em> such as
            <span class='code'>degree_F</span> or <span class='code'>mbar</span>. The reporting service uses this
            architecture to convert observations into a target unit system, to be displayed in your reports.
        </p>

        <p>With this architecture one can easily create reports with, say, wind measured in knots, rain measured in mm,
            and temperatures in degree Celsius. Or one can create a single set of templates, but display data in
            different unit systems with only a few stanzas in a configuration file.
        </p>


        <!-- -------------------------------------------------------------- -->

        <h1 id="customizing_reports">Customizing reports</h1>

        <p>
            There are two general mechanisms for customizing reports: change options in one or more configuration files,
            or change the template files. The former is generally easier, but occasionally the latter is necessary.
        </p>

        <h2 id="How_options_work">Options</h2>

        <p>
            Options are used to specify how reports will look and what they will contain. For example, they control
            which units to use, how to format dates and times, which data should be in each plot, the colors of plot
            elements, <em>etc</em>.
        </p>

        <p class="note">
            For a complete listing of the report options, see the section <a href="#report_options"><em>Reference:
            report options</em></a>.
        </p>

        <p>
            Options are read from three different types of <em>configuration files:</em>
        </p>
        <table class="indent" style="width:60%">
            <caption>Configuration files</caption>
            <thead>
            <tr class="first_row">
                <td>File</td>
                <td>Use</td>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td class="code">weewx.conf</td>
                <td>This is the application configuration file.  It contains general configuration information, such which drivers and services to load, as well as which
                    reports to run.  Report options can also be specified in this file.
                </td>
            </tr>
            <tr>
                <td class="code">skin.conf</td>
                <td>This is the skin configuration file.  It contains information specific to a <em>skin</em>, in particular, which template files to process, and
                    which plots to generate. Typically this file is supplied by the skin author.
                </td>
            </tr>
            <tr>
                <td class="code">en.conf<br/>de.conf<br/>fr.conf<br/><em>etc.</em></td>
                <td>These are internationalization files.  They contain language and locale information for a specific <em>skin</em>.</td>
            </tr>
            </tbody>
        </table>

        <p>
            Configuration files are read and processed using the Python utility <a
            href="https://configobj.readthedocs.io/en/latest/configobj.html">ConfigObj</a>, using a format similar to
            the MS-DOS <a href="https://en.wikipedia.org/wiki/INI_file">"INI" format</a>. Here's a simple example:
        </p>
        <pre class="tty">
[Section1]
    # A comment
    key1 = value1
    [[SubSectionA]]
        key2 = value2
[Section2]
    key3=value3</pre>
        <p>
            This example uses two sections at root level (sections <span class="code">Section1</span> and <span
            class="code">Section2</span>), and one sub-section (<span class="code">SubSectionA</span>), which is nested
            under <span class="code">Section1</span>. The option <span class="code">key1</span> is nested under <span
            class="code">Section1</span>, option <span class="code">key3</span> is nested under <span class="code">Section2</span>,
            while option <span class="code">key2</span> is nested under sub-section <span
            class="code">SubSectionA</span>.
        </p>
        <p class="note">
            Note that while this example indents sub-sections and options, this is strictly for readability &mdash; this
            isn't Python! It's the number of brackets that counts in determining nesting, not the indentation!
        </p>

        <p>
            Configuration files take advantage of <span class="code">ConfigObj's</span> ability to organize options
            hierarchically into <em>stanzas</em>. For example, the <span class="code">[Labels]</span> stanza contains
            the text that should be displayed for each observation. The <span class="code">[Units]</span> stanza
            contains other stanzas, each of which contains parameters that control the display of units.
        </p>


        <h3>Processing order</h3>
        <p>
            Configuration files and their sections are processed in a specific order. Generally, the values from the
            skin configuration file (<span class="code">skin.conf</span>) are processed first, then options in the WeeWX
            configuration file (nominally <span class="code">weewx.conf</span>) are applied last. This order allows skin
            authors to specify the basic look and feel of a report, while ensuring that users of the skin have the final
            say.
        </p>
        <p>
            To illustrate the processing order, here are the steps for the skin <em>Seasons</em>:
        </p>
        <ul>
            <li>
                First, a set of options defined in the Python module <span class="code">weewx.defaults</span> serve as
                the starting point.
            </li>
            <li>
                Next, options from the configuration file for <em>Seasons</em>, located in <span class="code">skins/Seasons/skin.conf</span>,
                are merged.
            </li>
            <li>
                Next, any options that apply to all skins, specified in the <span class="code">[StdReport] / [[Defaults]]</span>
                section of the WeeWX configuration file, are merged.
            </li>
            <li>
                Finally, any skin-specific options, specified in the <span class="code">[StdReport] / [[Seasons]]</span>
                section of the WeeWX configuration, are merged. These options have the final say.
            </li>
        </ul>

        <p>
            At all four steps, if a language specification is encountered (option <span class="code">lang</span>), then
            the corresponding language file will be read and merged. If a unit specification (option <span class="code">unit_system</span>)
            is encountered, then the appropriate unit groups are set. For example, if <span class="code">unit_system=metricwx</span>,
            then the unit for group pressure will be set to <span class="code">mbar</span>, etc.
        </p>

        <p>
            The result is the following option hierarchy, listed in order of increasing precedence.
        </p>

        <table class="indent" style="width: 90%">
            <caption>Option hierarchy, lowest to highest</caption>
            <thead>
            <tr class="first_row">
                <td>File</td>
                <td>Example</td>
                <td>Comments</td>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td class="code">weewx/defaults.py</td>
                <td class="code">
                    [Units]<br/> &nbsp;&nbsp;[[Labels]]<br/> &nbsp;&nbsp;&nbsp;&nbsp;mbar=" mbar"
                </td>
                <td>
                    These are the hard-coded default values for every option. They are used when an option is not
                    specified anywhere else. These should not be modified unless you propose a change to the WeeWX code;
                    any changes made here will be lost when the software is updated.
                </td>
            </tr>
            <tr>
                <td class="code">skin.conf</td>
                <td class="code">
                    [Units]<br/> &nbsp;&nbsp;[[Labels]]<br/> &nbsp;&nbsp;&nbsp;&nbsp;mbar=" hPa"
                </td>
                <td>
                    Supplied by the skin author, the skin configuration file, <span class="code">skin.conf</span>,
                    contains options that define the baseline behavior of the skin. In this example, for whatever
                    reasons, the skin author has decided that the label for units in millibars should be <span
                    class="code">" hPa"</span> (which is equivalent).
                </td>
            </tr>
            <tr>
                <td class="code">weewx.conf</td>
                <td class="code">
                    [StdReport]<br/> &nbsp;&nbsp;[[Defaults]]<br/> &nbsp;&nbsp;&nbsp;&nbsp;[[[Labels]]]<br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[[[Generic]]]]<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rain=Rainfall
                </td>
                <td>
                    Options specified under <span class="code">[[Defaults]]</span> apply to <em>all</em> reports. This
                    example indicates that the label <span class="example_text">Rainfall</span> should be used for the
                    observation <span class="code">rain</span>, in all reports.
                </td>
            </tr>
            <tr>
                <td class="code">weewx.conf</td>
                <td class="code">
                    [StdReport]<br/> &nbsp;&nbsp;[[SeasonsReport]]<br/> &nbsp;&nbsp;&nbsp;&nbsp;[[[Labels]]]<br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[[[Generic]]]]<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inTemp=Kitchen&nbsp;temperature
                </td>
                <td>
                    Highest precedence. Has the final say. Options specified here apply to a <em>single</em> report.
                    This example indicates that the label <span class="example_text">Kitchen temperature</span> should
                    be used for the observation <span class="code">inTemp</span>, but only for the report <em>SeasonsReport</em>.
                </td>
            </tr>
            </tbody>
        </table>

        <p class="note">
            <strong>Note:</strong> When specifying options, you must pay attention to the number of brackets! In the
            table above, there are two different nesting depths used: one for <span class="code">weewx.conf</span>, and
            one for <span class="code">weewx/defaults.py</span> and <span class="code">skin.conf</span>. This is because
            the stanzas defined in <span class="code">weewx.conf</span> start two levels down in the hierarchy <span
            class="code">[StdReport]</span>, whereas the stanzas defined in <span class="code">skin.conf</span> and
            <span class="code">defaults.py</span> are at the root level. Therefore, options specified in <span
            class="code">weewx.conf</span> must use two extra sets of brackets.
        </p>

        <p>
            Other skins are processed in a similar manner although, of course, their name will be something other
            than <em>Seasons</em>.
        </p>

        <p>
            Although it is possible to modify the options at any level, as the user of a skin, it is usually best to
            keep your modifications in the WeeWX configuration file (<span class="code">weewx.conf</span>) if you can.
            That way you can apply any fixes or changes when the skin author updates the skin, and your customizations
            will not be overwritten.
        </p>
        <p>
            If you are a skin author, then you should provide the skin configuration file (<span
            class="code">skin.conf</span>), and put in it only the options necessary to make the skin render the way you
            intend it. Any options that are likely to be localized for a specific language (in particular, text), should
            be put in the appropriate language file.
        </p>

        <h2 id="changing_languages">Changing languages</h2>
        <p>
            By default, the skins that come with WeeWX are set up for the English language, but suppose you wish to
            switch to another language. How you do so will depend on whether the skin you are using has been <em>internationalized</em>
            and, if so, whether it offers your local language.
        </p>

        <h3 id="internationalized_skins">Internationalized skins</h3>
        <p>
            All of the skins included with WeeWX have been internationalized, so if you're working with one of them,
            this is the section you want. Next, you need to check whether there is a <em>localization</em> file for your
            particular language. To check, look in the contents of subdirectory <span class="code">lang</span> in the
            skin's directory. For example, if you used a package installer and are using the <em>Seasons</em> skin, you
            will want to look in <span class="code">/etc/weewx/skins/Seasons/lang</span>. Inside, you will see something
            like this:
        </p>
        <pre class="tty">ls -l /etc/weewx/skins/Seasons/lang
total 136
-rw-rw-r-- 1 tkeffer tkeffer  9447 Jul  1 11:11 cn.conf
-rw-rw-r-- 1 tkeffer tkeffer  9844 Mar 13 12:31 cz.conf
-rw-rw-r-- 1 tkeffer tkeffer  9745 Mar 13 12:31 de.conf
-rw-rw-r-- 1 tkeffer tkeffer  9459 Mar 13 12:31 en.conf
-rw-rw-r-- 1 tkeffer tkeffer 10702 Mar 13 12:31 es.conf
-rw-rw-r-- 1 tkeffer tkeffer 10673 May 31 07:50 fr.conf
-rw-rw-r-- 1 tkeffer tkeffer 11838 Mar 13 12:31 gr.conf
-rw-rw-r-- 1 tkeffer tkeffer  9947 Mar 13 12:31 it.conf
-rw-rw-r-- 1 tkeffer tkeffer  9548 Mar 13 12:31 nl.conf
-rw-rw-r-- 1 tkeffer tkeffer 10722 Apr 15 14:52 no.conf
-rw-rw-r-- 1 tkeffer tkeffer 15356 Mar 13 12:31 th.conf
</pre>

        <p>
            This means that the <em>Seasons</em> skin has been localized for the following languages:
        </p>

        <table class="indent" style="width:30%">
            <tbody>
            <tr class="first_row">
                <td>File</td>
                <td>Language</td>
            </tr>
            <tr>
                <td class="code">cn.conf</td>
                <td>Traditional Chinese</td>
            </tr>
            <tr>
                <td class="code">cz.conf</td>
                <td>Czeck</td>
            </tr>
            <tr>
                <td class="code">de.conf</td>
                <td>German</td>
            </tr>
            <tr>
                <td class="code">en.conf</td>
                <td>English</td>
            </tr>
            <tr>
                <td class="code">es.conf</td>
                <td>Spanish</td>
            </tr>
            <tr>
                <td class="code">fr.conf</td>
                <td>French</td>
            </tr>
            <tr>
                <td class="code">it.conf</td>
                <td>Italian</td>
            </tr>
            <tr>
                <td class="code">gr.conf</td>
                <td>Greek</td>
            </tr>
            <tr>
                <td class="code">nl.conf</td>
                <td>Dutch</td>
            </tr>
            <tr>
                <td class="code">th.conf</td>
                <td>Thai</td>
            </tr>
            </tbody>
        </table>

        <p>
            If you want to use the <em>Seasons</em> skin and are working with one of these languages, then you are in
            luck: you can simply override the <span class="code">lang</span> option. For example, to change the language
            displayed by the <em>Seasons</em> skin from English to German, edit <span class="code">weewx.conf</span>,
            and change the highlighted section:
        </p>

        <pre class="tty">
[StdReport]
    ...
    [[SeasonsReport]]
        # The SeasonsReport uses the 'Seasons' skin, which contains the
        # images, templates and plots for the report.
        skin = Seasons
        enable = true
        lang = <span class="highlight">de</span>
</pre>

        <p>
            By contrast, if the skin has been internationalized, but there is no localization file for your language,
            then you will have to supply one. See the section <a href="#internationalized-missing-language"><em>Internationalized,
            but your language is missing</em></a>.
        </p>


        <h2 id="how_to_change_datetime_format">Changing date and time formats</h2>
        <p>
          Date and time formats are specified using the same format strings used by <a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior"> strftime()</a>.  For example, <span class="code">%Y</span> indicates the 4-digit year, and <span class="code">%H:%M</span> indicates the time in hours:minutes.  The default values for date and time formats are generally <span class="code">%x %X</span>, which indicates "use the format for the locale of the computer".
        </p>
        <p>
          Since date formats default to the locale of the computer, a date might appear with the format of "month/day/year".  What if you prefer dates to have the format "year.month.day"?  How do you indicate 24-hour time format versus 12-hour?
        </p>
        <p>
          Dates and times generally appear in two places: in plots and in tags.
        </p>

        <h3 id="datetime_format_images">Date and time formats in images</h3>
        <p>
          Most plots have a label on the horizontal axis that indicates when the plot was generated.  By default, the format for this label uses the locale of the computer on which WeeWX is running, but you can modify the format by specifying the option <span class="code">bottom_label_format</span>.
        </p>
        <p>
          For example, this would result in a date/time string such as "2021.12.13 12:45" no matter what the computer's locale:
        </p>

        <pre class="tty">
[StdReport]
    ...
    [[Defaults]]
        [[[ImageGenerator]]]
            [[[[day_images]]]]
                bottom_label_format = %Y.%m.%d %H:%M
            [[[[week_images]]]]
                bottom_label_format = %Y.%m.%d %H:%M
            [[[[month_images]]]]
                bottom_label_format = %Y.%m.%d %H:%M
            [[[[year_images]]]]
                bottom_label_format = %Y.%m.%d %H:%M</pre>

        <h3 id="datetime_format_tags">Date and time formats for tags</h3>
        <p>
          Each aggregation period has a format for the times associated with that period.  These formats are defined in the <span class="code">TimeFormats</span> section.  The default format for each uses the date and/or time for the computer of the locale on which WeeWX is running.
        </p>
        <p>
          For example, this would result in a date/time string such as "2021.12.13 12:45" no matter what the computer's locale:
        </p>

        <pre class="tty">
[StdReport]
    ...
    [[Defaults]]
        [[[Units]]]
            [[[[TimeFormats]]]]
                hour        = %H:%M
                day         = %Y.%m.%d
                week        = %Y.%m.%d (%A)
                month       = %Y.%m.%d %H:%M
                year        = %Y.%m.%d %H:%M
                rainyear    = %Y.%m.%d %H:%M
                current     = %Y.%m.%d %H:%M
                ephem_day   = %H:%M
                ephem_year  = %Y.%m.%d %H:%M</pre>

        <h2 id="how_to_change_units">Changing unit systems</h2>

        <p>
            Each <em>unit system</em> is a set of units. For example, the <span class="code">METRIC</span> unit system
            uses centimeters for rain, kilometers per hour for wind speed, and degree Celsius for temperature. The
            option <a href="usersguide.htm#option-unit-system"><span class="code">unit_system</span></a> controls which
            unit system will be used in your reports. The available choices are <span class="code">US</span>, <span
            class="code">METRIC</span>, or <span class="code">METRICWX</span>. The option is case-insensitive. See the
            <a href="#units"><em>Appendix Units</em></a> for the unit defined in each of these unit systems.
        </p>
        <p>
            By default, WeeWX uses <span class="code">US</span> (US Customary) system. Suppose you would rather use the
            <span class="code">METRICWX</span> system for all your reports? Then change this
        </p>

        <pre class="tty">
[StdReport]
    ...
    [[Defaults]]

        # Which unit system to use for all reports. Choices are 'us', 'metric', or 'metricwx'.
        # You can override this for individual reports.
        <span class="highlight">unit_system = us</span></pre>
        <p>
            to this
        </p>

        <pre class="tty">
[StdReport]
    ...
    [[Defaults]]

        # Which unit system to use for all reports. Choices are 'us', 'metric', or 'metricwx'.
        # You can override this for individual reports.
        <span class="highlight">unit_system = metricwx</span></pre>

        <h3 id="mixed_units">Mixed units</h3>
        <p>
            However, what if you want a mix? For example, suppose you generally want US Customary units, but you want
            barometric pressures to be in millibars? This can be done by <em>overriding</em> the appropriate unit group.
        </p>

        <pre class="tty">
[StdReport]
    ...
    [[Defaults]]

        # Which unit system to use for all reports. Choices are 'us', 'metric', or 'metricwx'.
        # You can override this for individual reports.
        unit_system = us

        # Override the units used for pressure:
        <span class=highlight>[[[Units]]]</span>
            <span class=highlight>[[[[Groups]]]]</span>
                <span class=highlight>group_pressure = mbar</span>
</pre>

        <p>
            This says that you generally want the <span class="code">US</span> systems of units for all reports, but
            want pressure to be reported in <em>millibars</em>. Other units can be overridden in a similar manner.
        </p>

        <h3 id="change_units">Multiple unit systems</h3>

        <p>Another example. Suppose we want to generate <em>two</em> reports, one in the US Customary system, the other
            using the <span class="code">METRICWX</span> system. The first, call it <em>SeasonsUSReport</em>, will go in
            the regular directory <span class="symcode">HTML_ROOT</span>. However, the latter, call it <em>SeasonsMetricReport</em>,
            will go in a subdirectory, <span class="symcode">HTML_ROOT</span><span class="code">/metric</span>. Here's
            how you would do it
        </p>
        <pre class="tty">
[StdReport]

    # Where the skins reside, relative to WEEWX_ROOT
    SKIN_ROOT = skins

    # Where the generated reports should go, relative to WEEWX_ROOT
    HTML_ROOT = public_html

    # The database binding indicates which data should be used in reports.
    data_binding = wx_binding

    <span class="highlight">[[SeasonsUSReport]]</span>
        skin = Seasons
        <span class="higlight">unit_system = us</span>
        enable = true

    <span class="highlight">[[SeasonsMetricReport]]</span>
        skin = Seasons
        unit_system = metricwx
        HTML_ROOT = public_html/metric
        enable = true
</pre>

        <p>
            Note how both reports use the same <em>skin</em> (that is, skin <em>Seasons</em>), but different unit
            systems, and different destinations. The first, <em>SeasonsUSReport</em> sets option <span class="code">unit_system</span>
            to <span class="code">us</span>, and uses the default destination. By contrast, the second, <em>SeasonsMetricReport</em>,
            uses unit system <span class="code">metricwx</span>, and a different destination, <span class="code">public_html/metric</span>.
        </p>


        <h2 id="how_to_change_labels">Changing labels</h2>
        <p>
            Every observation type is associated with a default <em>label</em>. For example, in the English language,
            the default label for observation type <span class="code">outTemp</span> is generally <span class="example_text">Outside
            Temperature</span>. You can change this label by <em>overriding</em> the default. How you do so will depend on
            whether the skin you are using has been <em>internationalized</em> and, if so, whether it offers your local
            language.
        </p>

        <p>
            Let's look at an example. If you take a look inside the file <span
            class="code">skins/Seasons/lang/en.conf</span>, you will see it contains what looks like a big configuration
            file. Among other things, it has two entries that look like this:
        </p>
        <pre class="tty">
...
[Labels]
    ...
    [[Generic]]
        ...
        inTemp = Inside Temperature
        outTemp = Outside Temperature
        ...</pre>

        <p>
            This tells the report generators that when it comes time to label the observation variables <span
            class="code">inTemp</span> and <span class="code">outTemp</span>, use the strings <span
            class="example_text">Inside Temperature</span> and <span class="example_text">Outside
            Temperature</span>, respectively.
        </p>
        <p>
            However, let's say that we have actually located our outside temperature sensor in the barn, and wish to
            label it accordingly. We need to <em>override</em> the label that comes in the localization file. We could
            just change the localization file <span class="code">en.conf</span>, but then if the author of the skin came
            out with a new version, our change could get lost. Better to override the default by making the change in
            <span class="code">weewx.conf</span>. To do this, make the following changes in <span class="code">weewx.conf</span>:
        </p>
        <pre class="tty">
    [[SeasonsReport]]
        # The SeasonsReport uses the 'Seasons' skin, which contains the
        # images, templates and plots for the report.
        skin = Seasons
        lang = en
        unit_system = US
        enable = true
        <span class=highlight>[[[Labels]]]</span>
            <span class=highlight>[[[[Generic]]]]</span>
                <span class=highlight>outTemp = Barn Temperature</span>
        </pre>

        <p>
            This will cause the default label <span class="example_text">Outside Temperature</span> to be replaced with
            the new label <span class="example_text">Barn
            Temperature</span> everywhere in your report. The label for type <span class="code">inTemp</span> will be
            untouched.
        </p>

        <h2 id="customizing_gen_time">Scheduling report generation</h2>

        <p>
            Normal WeeWX operation is to run each <em><a href="usersguide.htm#Reports">report</a></em> defined in <span
            class="code">weewx.conf</span> every archive period. While this may suit most situations, there may be
            occasions when it is desirable to run a report less frequently than every archive period. For example, the
            archive interval might be 5 minutes, but you only want to FTP files every 30 minutes, once per day, or at a
            set time each day. WeeWX has two mechanisms that provide the ability to control when files are generated.
            The <em><a href="#stale_age"><span class="code">stale_age</span></a></em> option allows control over the age
            of a file before it is regenerated, and the <span class="code">report_timing</span> option allows precise
            control over when individual reports are run.
        </p>

        <p class="note" style="display: inline-block; width: 70%">
            <strong>Note</strong><br/>While <span class="code">report_timing</span> specifies when a given report
            should be generated, the generation of reports is still controlled by the WeeWX report cycle, so reports can
            never be generated more frequently than once every archive period.
        </p>

        <h3>The <span class="code">report_timing</span> option</h3>

        <p>
            The <span class="code">report_timing</span> option uses a CRON-like format to control when a report is to be
            run. While a CRON-like format is used, the control of WeeWX report generation using the <span
            class="code">report_timing</span> option is confined completely to WeeWX and has no interraction with the
            system CRON service.
        </p>

        <p>
            The <span class="code">report_timing</span> option consists of five parameters separated by white-space:
        </p>

        <pre class="tty">report_timing = minutes hours day_of_month months day_of_week</pre>

        <p>
            The <span class="code">report_timing</span> parameters are summarised in the following table:
        </p>

        <table class="indent">
            <tbody>
            <tr class="first_row">
                <td>Parameter</td>
                <td style="width:20%">Function</td>
                <td>Allowable values</td>
            </tr>
            <tr>
                <td class="code first_col">minutes</td>
                <td>Specifies the minutes of the hour when the report will be run
                </td>
                <td><span class="code">*</span>, or<br/>numbers in the range 0..59 inclusive
                </td>
            </tr>
            <tr>
                <td class="code first_col">hours</td>
                <td>Specifies the hours of the day when the report will be run
                </td>
                <td><span class="code">*</span>, or<br/>numbers in the range 0..23 inclusive
                </td>
            </tr>
            <tr>
                <td class="code first_col">day_of_month</td>
                <td>Specifies the days of the month when the report will be run
                </td>
                <td><span class="code">*</span>, or<br/>numbers in the range 1..31 inclusive
                </td>
            </tr>
            <tr>
                <td class="code first_col">months</td>
                <td>Specifies the months of the year when the report will be run
                </td>
                <td><span class="code">*</span>, or<br/>numbers in the range 1..12 inclusive, or<br/>abbreviated names in the range jan..dec
                    inclusive
                </td>
            </tr>
            <tr>
                <td class="code first_col">day_of_week</td>
                <td>Specifies the days of the week when the report will be run
                </td>
                <td><span class="code">*</span>, or<br/>numbers in the range 0..7 inclusive (0,7 = Sunday, 1 = Monday etc), or<br/>abbreviated
                    names in the range sun..sat inclusive
                </td>
            </tr>
            </tbody>
        </table>

        <p>
            The <span class="code">report_timing</span> option may only be used in <span class="code">weewx.conf</span>.
            When set in the <span class="code">[StdReport]</span> section of <span class="code">weewx.conf</span> the
            option will apply to all reports listed under <span class="code">[StdReport]</span>. When specified within a
            report section, the option will override any setting in <span class="code">[StdReport]</span> for that
            report. In this manner it is possible to have different reports run at different times. The following sample
            <span class="code">weewx.conf</span> excerpt illustrates this:
        </p>

        <pre class="tty">
[StdReport]

    # Where the skins reside, relative to WEEWX_ROOT
    SKIN_ROOT = skins

    # Where the generated reports should go, relative to WEEWX_ROOT
    HTML_ROOT = public_html

    # The database binding indicates which data should be used in reports.
    data_binding = wx_binding

    # Report timing parameter
    report_timing = 0 * * * *

    # Each of the following subsections defines a report that will be run.

    [[AReport]]
        skin = SomeSkin

    [[AnotherReport]]
        skin = SomeOtherSkin
        report_timing = */10 * * * *</pre>

        <p>
            In this case, the <span class="code">[[AReport]]</span> report would be run under under control of the <span
            class="code">0 * * * *</span> setting (on the hour) under <span class="code">[StdReport]</span> and the
            <span class="code">[[AnotherReport]]</span> report would be run under control of the <span class="code">*/10 * * * *</span>
            setting (every 10 minutes) which has overriden the <span class="code">[StdReport]</span> setting.
        </p>

        <h3>How <span class="code">report_timing</span> controls reporting </h3>

        <p>
            The syntax and interpretation of the <span class="code">report_timing</span> parameters are largely the same
            as those of the CRON service in many Unix and Unix-like operating systems. The syntax and interpretation are
            outlined below.
        </p>

        <p>
            When the <span class="code">report_timing</span> option is in use WeeWX will run a report when the minute,
            hour and month of year parameters match the report time, and at least one of the two day parameters (day of
            month or day of week) match the report time. This means that non-existent times, such as "missing hours"
            during daylight savings changeover, will never match, causing reports scheduled during the "missing times"
            not to be run. Similarly, times that occur more than once (again, during daylight savings changeover) will
            cause matching reports to be run more than once.
        </p>

        <p class="note" style="display: inline-block; width: 70%">
            <strong>Note</strong><br/>Report time does not refer to the time at which the report is run, but rather the
            date and time of the latest data the report is based upon. If you like, it is the effective date and time of
            the report. For normal WeeWX operation, the report time aligns with the <span class="code">dateTime</span>
            of the most recent archive record. When reports are run using the <span class="code">wee_reports</span>
            utility, the report time is either the <span class="code">dateTime</span> of the most recent archive record
            (the default) or the optional timestamp command line argument.
        </p>

        <p class="note" style="display: inline-block; width: 70%">
            <strong>Note</strong><br/>The day a report is to be run can be specified by two parameters; day of month
            and/or day of week. If both parameters are restricted (i.e., not an asterisk), the report will be run when
            either field matches the current time. For example,<br/> <span class="code">report_timing = 30 4
          1,15 * 5</span><br/> would cause the report to be run at 4:30am on the 1st and 15th of each month as well as
            4:30am every Friday.
        </p>

        <h3>The relationship between <span class="code">report_timing</span> and archive period </h3>

        <p>
            A traditional CRON service has a resolution of one minute, meaning that the CRON service checks each minute
            as to whether to execute any commands. On the other hand, the WeeWX report system checks which reports are
            to be run once per archive period, where the archive period may be one minute, five minutes, or some other
            user defined period. Consequently, the <span class="code">report_timing</span> option may specify a report
            to be run at some time that does not align with the WeeWX archive period. In such cases the <span
            class="code">report_timing</span> option does not cause a report to be run outside of the normal WeeWX
            report cycle, rather it will cause the report to be run during the next report cycle. At the start of each
            report cycle, and provided a <span class="code">report_timing</span> option is set, WeeWX will check each
            minute boundary from the current report time back until the report time of the previous report cycle. If a
            match is found on <strong>any</strong> of these one minute boundaries the report will be run during the
            report cycle. This may be best described through some examples:
        </p>

        <table class="indent">
            <tbody>
            <tr class="first_row">
                <td class="code">report_timing</td>
                <td>Archive period</td>
                <td>When the report will be run</td>
            </tr>
            <tr>
                <td class="code first_col">0 * * * *</td>
                <td>5 minutes</td>
                <td>The report will be run only during the report cycle commencing on the hour.</td>
            </tr>
            <tr>
                <td class="code first_col">5 * * * *</td>
                <td>5 minutes</td>
                <td>The report will be run only during the report cycle commencing at 5 minutes past the hour.</td>
            </tr>
            <tr>
                <td class="code first_col">3 * * * *</td>
                <td>5 minutes</td>
                <td>The report will be run only during the report cycle commencing at 5 minutes past the hour.</td>
            </tr>
            <tr>
                <td class="code first_col">10 * * * *</td>
                <td>15 minutes</td>
                <td>The report will be run only during the report cycle commencing at 15 minutes past the hour</td>
            </tr>
            <tr>
                <td class="code first_col">10,40 * * * *</td>
                <td>15 minutes</td>
                <td>The report will be run only during the report cycles commencing at 15 minutes past the hour and 45
                    minutes past the hour.
                </td>
            </tr>
            <tr>
                <td class="code first_col">5,10 * * * *</td>
                <td>15 minutes</td>
                <td>The report will be run once only during the report cycle commencing at 15 minutes past the hour.
                </td>
            </tr>
            </tbody>
        </table>

        <h3>Lists, ranges and steps</h3>

        <p>
            The <span class="code">report_timing</span> option supports lists, ranges, and steps for all parameters.
            Lists, ranges, and steps may be used as follows:
        </p>

        <ul>
            <li>
                <em>Lists</em>. A list is a set of numbers (or ranges) separated by commas, for example <span class="code">1, 2,
                5, 9</span> or <span class="code">0-4, 8-12</span>. A match with any of the elements of the list will
                result in a match for that particular parameter. If the examples were applied to the minutes parameter,
                and subject to other parameters in the <span class="code">report_timing</span> option, the report would
                be run at minutes 1, 2, 5, and 9 and 0, 1, 2, 3, 4, 8, 9, 10, 11, and 12 respectively. Abbreviated month
                and day names cannot be used in a list.
            </li>

            <li>
                <em>Ranges</em>. Ranges are two numbers separated with a hyphen, for example <span
                class="code">8-11</span>. The specified range is inclusive. A match with any of the values included in
                the range will result in a match for that particular parameter. If the example was applied to the hours
                parameter, and subject to other parameters in the <span class="code">report_timing</span> option, the
                report would be run at hours 8, 9, 10, and 11. A range may be included as an element of a list.
                Abbreviated month and day names cannot be used in a range.
            </li>

            <li>
                <em>Steps</em>. A step can be used in conjunction with a range or asterisk and are denoted by a '<span
                class="code">/</span>' followed by a number. Following a range with a step specifies skips of the step
                number's value through the range. For example, <span class="code">0-12/2</span> used in the hours
                parameter would, subject to other parameter in the <span class="code">report_timing</span> option, run
                the report at hours 0, 2, 4, 6, 8, and 12. Steps are also permitted after an asterisk in which case the
                skips of the step number's value occur through the all possible values of the parameter. For example,
                <span class="code">*/3</span> can be used in the hours parameter to, subject to other parameter in the
                <span class="code">report_timing</span> option, run the report at hours 0, 3, 6, 9, 12, 15, 18, and 21.
            </li>
        </ul>

        <h3>Nicknames</h3>

        <p>
            The <span class="code">report_timing</span> option supports a number of time specification 'nicknames'.
            These nicknames are prefixed by the '<span class="code">@</span>' character and replace the five parameters
            in the <span class="code">report_timing</span> option. The nicknames supported are:
        </p>

        <table class="indent">
            <tbody>
            <tr class="first_row">
                <td>Nickname</td>
                <td>Equivalent setting
                </td>
                <td>When the report will be run</td>
            </tr>
            <tr>
                <td class="code first_col">@yearly<br/>@annually
                </td>
                <td>0 0 1 1 *</td>
                <td>Once per year at midnight on 1 January.</td>
            </tr>
            <tr>
                <td class="code first_col">@monthly</td>
                <td>0 0 1 * *</td>
                <td>Monthly at midnight on the 1st of the month.</td>
            </tr>
            <tr>
                <td class="code first_col">@weekly</td>
                <td>0 0 * * 0</td>
                <td>Every week at midnight on Sunday.</td>
            </tr>
            <tr>
                <td class="code first_col">@daily</td>
                <td>0 0 * * *</td>
                <td>Every day at midnight.</td>
            </tr>
            <tr>
                <td class="code first_col">@hourly</td>
                <td>0 * * * *</td>
                <td>Every hour on the hour.</td>
            </tr>
            </tbody>
        </table>

        <h3>Examples of <span class="code">report_timing</span></h3>

        <p>
            Numeric settings for <span class="code">report_timing</span> can be at times difficult to understand due to
            the complex combinations of parameters. The following table shows a number of example <span class="code">report_timing</span>
            options and the corresponding times when the report would be run.
        </p>

        <table class="indent">
            <tbody>
            <tr class="first_row">
                <td class="code">report_timing</td>
                <td>When the report will be run</td>
            </tr>
            <tr>
                <td class="code first_col">* * * * *</td>
                <td>Every archive period. This setting is effectively the default WeeWX method of operation.
                </td>
            </tr>
            <tr>
                <td class="code first_col">25 * * * *</td>
                <td>25 minutes past every hour.</td>
            </tr>
            <tr>
                <td class="code first_col">0 * * * *</td>
                <td>Every hour on the hour.</td>
            </tr>
            <tr>
                <td class="code first_col">5 0 * * *</td>
                <td>00:05 daily.</td>
            </tr>
            <tr>
                <td class="code first_col">25 16 * * *</td>
                <td>16:25 daily.</td>
            </tr>
            <tr>
                <td class="code first_col">25 16 1 * *</td>
                <td>16:25 on the 1st of each month.</td>
            </tr>
            <tr>
                <td class="code first_col">25 16 1 2 *</td>
                <td>16:25 on the 1st of February.</td>
            </tr>
            <tr>
                <td class="code first_col">25 16 * * 0</td>
                <td>16:25 each Sunday.</td>
            </tr>
            <tr>
                <td class="code first_col">*/10 * * * *</td>
                <td>On the hour and 10, 20, 30, 40 and 50 mnutes past the hour.
                </td>
            </tr>
            <tr>
                <td class="code first_col">*/9 * * * *</td>
                <td>On the hour and 9, 18, 27, 36, 45 and 54 minutes past the hour.
                </td>
            </tr>
            <tr>
                <td class="code first_col">*/10 */2 * * *</td>
                <td>0, 10, 20, 30, 40 and 50 minutes after the even hour.
                </td>
            </tr>
            <tr>
                <td class="code first_col">* 6-17 * * *</td>
                <td>Every archive period from 06:00 (inclusive) up until, but excluding, 18:00.
                </td>
            </tr>
            <tr>
                <td class="code first_col">* 1,4,14 * * *</td>
                <td>Every archive period in the hour starting 01:00 to 01:59, 04:00 to 04:59 amd 14:00 to 14:59 (Note
                    excludes report times at 02:00, 05:00 and 15:00).
                </td>
            </tr>
            <tr>
                <td class="code first_col">0 * 1 * 0,3</td>
                <td>On the hour on the first of the month and on the hour every Sunday and Wednesday.
                </td>
            </tr>
            <tr>
                <td class="code first_col">*&nbsp;*&nbsp;21,1-10/3&nbsp;6&nbsp;*</td>
                <td>Every archive period on the 1st, 4th, 7th, 10th and 21st of June.
                </td>
            </tr>
            <tr>
                <td class="code first_col">@monthly</td>
                <td>Midnight on the 1st of the month.</td>
            </tr>
            </tbody>
        </table>

        <h3>
            The <span class="code">wee_reports</span> utility and the <span class="code">report_timing</span> option
        </h3>

        <p>
            The <span class="code">report_timing</span> option is ignored when using the <a href="#wee_reports">wee_reports</a>
            utility.
        </p>


        <!-- -------------------------------------------------------------- -->

        <h1 id="customizing_templates">The Cheetah generator</h1>

        <p class="note">
            This section gives an overview of the Cheetah generator. For details about each of its various options, see
            the section <a href="#CheetahGenerator"><em>[CheetahGenerator]</em></a> in the <a
            href="#report_options"><em>Reference: report options</em></a>.
        </p>

        <p>
            File generation is done using the <a href="https://pythonhosted.org/Cheetah/">Cheetah</a> templating engine,
            which processes a <em>template</em>, replacing any symbolic <em>tags</em>, then produces an output file.
            Typically, it runs after each new archive record (usually about every five minutes), but it can also run on
            demand using the <span class="code">wee_reports</span> utility.
        </p>
        <p>
            The Cheetah engine is very powerful, essentially letting you have the full semantics of Python available in
            your templates. As this would make the templates incomprehensible to anyone but a Python programmer, WeeWX
            adopts a very small subset of its power.
        </p>
        <p>
            The Cheetah generator is controlled by the section <a href="#CheetahGenerator"><span class="code">[CheetahGenerator]</span></a>.
            Let's take a look at how this works.
        </p>

        <h2>Which files get processed?</h2>

        <p>
            Each template file is named something like <span class="code"><em>D/F.E.tmpl</em></span>, where <span
            class="code">D</span> is the (optional) directory the template sits in and will also be the directory the
            results will be put in, and <span class="code">F.E</span> is the generated file name. So, given a template
            file with name <span class="code">Acme/index.html.tmpl</span>, the results will be put in <span
            class="symcode">HTML_ROOT</span><span class="code">/Acme/index.html</span>.
        </p>

        <p>
            The configuration for a group of templates will look something like this:
        </p>
        <pre class="tty">[CheetahGenerator]
    [[index]]
        template = index.html.tmpl
    [[textfile]]
        template = filename.txt.tmpl
    [[xmlfile]]
        template = filename.xml.tmpl</pre>
        <p>
            There can be only one <span class="config_option">template</span> in each block. In most cases, the block
            name does not matter &mdash; it is used only to isolate each template. However, there are four block names
            that have special meaning: <span class="code">SummaryByDay</span>, <span class='code'>SummaryByMonth</span>,
            <span class='code'>SummaryByYear</span>, and <span class='code'>ToDate</span>.
        </p>

        <h3 id="Specifying_template_files">Specifying template files</h3>

        <p>
            By way of example, here is the <span class="code">[CheetahGenerator]</span> section from the <span
            class="code">skin.conf</span> for the skin <em>Seasons</em>.
        </p>

        <pre class="tty">[CheetahGenerator]
    # The CheetahGenerator creates files from templates.  This section
    # specifies which files will be generated from which template.

    # Possible encodings include 'html_entities', 'strict_ascii', 'normalized_ascii',
    # as well as those listed in https://docs.python.org/3/library/codecs.html#standard-encodings
    encoding = html_entities

    [[SummaryByMonth]]
        # Reports that summarize "by month"
        [[[NOAA_month]]]
            encoding = normalized_ascii
            template = NOAA/NOAA-%Y-%m.txt.tmpl

    [[SummaryByYear]]
        # Reports that summarize "by year"
        [[[NOAA_year]]]
            encoding = normalized_ascii
            template = NOAA/NOAA-%Y.txt.tmpl

    [[ToDate]]
        # Reports that show statistics "to date", such as day-to-date,
        # week-to-date, month-to-date, etc.
        [[[index]]]
            template = index.html.tmpl
        [[[statistics]]]
            template = statistics.html.tmpl
        [[[telemetry]]]
            template = telemetry.html.tmpl
        [[[tabular]]]
            template = tabular.html.tmpl
        [[[celestial]]]
            template = celestial.html.tmpl
            # Uncomment the following to have WeeWX generate a celestial page only once an hour:
            # stale_age = 3600
        [[[RSS]]]
            template = rss.xml.tmpl
    </pre>

        <p>The skin contains three different kinds of generated output:</p>
        <ol>
            <li>Summary by Month. The skin uses <span class="code">SummaryByMonth</span> to produce NOAA summaries, one
                for each month, as a simple text file.
            </li>
            <li>Summary by Year. The skin uses <span class="code">SummaryByYear</span> to produce NOAA summaries, one
                for each year, as a simple text file.
            </li>
            <li>Summary "To Date". The skin produces an HTML <span class="code">index.html</span> page, as well as HTML
                files for detailed statistics, telemetry, and celestial information. It also includes a master page
                (<span class="code">tabular.html</span>) in which NOAA information is displayed. All these files are
                HTML.
            </li>
        </ol>
        <p>
            Because the option
        </p>
        <pre class="tty">
    encoding = html_entities
        </pre>
        <p>
            appears directly under <span class="code">[StdReport]</span>, this will be the default encoding of the
            generated files unless explicitly overridden. We see an example of this under <span class="code">[SummaryByMonth]</span>
            and <span class="code">
            [SummaryByYear]</span>, which use option <span class="code">normalized_ascii</span> instead (replaces
            accented characters with a non-accented analog).
        </p>

        <p>
            Other than <span class="code">SummaryByMonth</span> and <span class="code">SummaryByYear</span>, the section
            names are arbitrary. <span class="code">ToDate</span> could just as well have been called <span
            class="code">files_to_date</span>, and the sections <span class="code">index</span>, <span class="code">statistics</span>,
            and <span class="code">telemetry</span> could just as well have been called <span class="code">tom</span>,
            <span class="code">dick</span>, and <span class="code">harry</span>.
        </p>

        <h3><span class="code" id="SummaryByYear">[[SummaryByYear]]</span></h3>

        <p>
            Use <span class="code">SummaryByYear</span> to generate a set of files, one file per year. The name of the
            template file should contain a <a
            href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior"> strftime()</a> code for
            the year; this will be replaced with the year of the data in the file.
        </p>
        <pre class="tty">
[CheetahGenerator]
    [[SummaryByYear]]
        # Reports that summarize "by year"
        [[[NOAA_year]]]
            encoding = normalized_ascii
            template = NOAA/NOAA-%Y.txt.tmpl
        </pre>

        <p>
            The template <span class="code">NOAA/NOAA-%Y.txt.tmpl</span> might look something like this:
        </p>
        <pre class="tty">
           SUMMARY FOR YEAR $year.dateTime

MONTHLY TEMPERATURES AND HUMIDITIES:
#for $record in $year.records
$record.dateTime $record.outTemp $record.outHumidity
#end for
        </pre>

        <h3><span class="code" id="SummaryByMonth">[[SummaryByMonth]]</span></h3>

        <p>
            Use <span class="code">SummaryByMonth</span> to generate a set of files, one file per month. The name of the
            template file should contain a <a
            href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior"> strftime()</a> code for
            year and month; these will be replaced with the year and month of the data in the file.
        </p>
        <pre class="tty">
[CheetahGenerator]
    [[SummaryByMonth]]
        # Reports that summarize "by month"
        [[[NOAA_month]]]
            encoding = normalized_ascii
            template = NOAA/NOAA-%Y-%m.txt.tmpl
        </pre>

        <p>
            The template <span class="code">NOAA/NOAA-%Y-%m.txt.tmpl</span> might look something like this:
        </p>
        <pre class="tty">
           SUMMARY FOR MONTH $month.dateTime

DAILY TEMPERATURES AND HUMIDITIES:
#for $record in $month.records
$record.dateTime $record.outTemp $record.outHumidity
#end for
        </pre>

        <h3><span class="code" id="SummaryByDay">[[SummaryByDay]]</span></h3>
        <p>
            While the <em>Seasons</em> skin does not make use of it, there is also a <span
            class="code">SummaryByDay</span> capability. As the name suggests, this results in one file per day. The
            name of the template file should contain a <a
            href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior"> strftime()</a> code for
            the year, month and day; these will be replaced with the year, month, and day of the data in the file.
        </p>
        <pre class="tty">
[CheetahGenerator]
    [[SummaryByDay]]
        # Reports that summarize "by day"
        [[[NOAA_day]]]
            encoding = normalized_ascii
            template = NOAA/NOAA-%Y-%m-%d.txt.tmpl
        </pre>

        <p>
            The template <span class="code">NOAA/NOAA-%Y-%m-%d.txt.tmpl</span> might look something like this:
        </p>
        <pre class="tty">
           SUMMARY FOR DAY $day.dateTime

HOURLY TEMPERATURES AND HUMIDITIES:
#for $record in $day.records
$record.dateTime $record.outTemp $record.outHumidity
#end for
        </pre>
        <p class="note">
            <strong>Note</strong><br/> This can create a <em>lot</em> of files &mdash; one per day. If you have 3 years
            of records, this would be more than 1,000 files!
        </p>

        <h2>Tags</h2>

        <p>
            If you look inside a template, you will see it makes heavy use of <em>tags</em>. As the Cheetah generator
            processes the template, it replaces each tag with an appropriate value and, sometimes, a label. This section
            discusses the details of how that happens.
        </p>

        <p class="note">
            If there is a tag error during template generation, the error will show up in the log file. Many errors are
            obvious &mdash; Cheetah will display a line number and list the template file in which the error occurred.
            Unfortunately, in other cases, the error message can be very cryptic and not very useful. So make small
            changes and test often. Use the utility <a href="#wee_reports"><span class="code">wee_reports</span></a> to
            speed up the process.
        </p>
        <p>Here are some examples of tags:</p>
        <pre class="tty">$current.outTemp
$month.outTemp.max
$month.outTemp.maxtime</pre>
        <p>
            These code the current outside temperature, the maximum outside temperature for the month, and the time that
            maximum occurred, respectively. So a template file that contains:
        </p>
        <pre class="tty">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Current conditions&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;Current temperature = $current.outTemp&lt;/p&gt;
        &lt;p&gt;Max for the month is $month.outTemp.max, which occurred at $month.outTemp.maxtime&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>
        <p>
            would be all you need for a very simple HTML page that would display the text (assuming that the unit group
            for temperature is <span class="code">degree_F</span>):
        </p>

        <p class="example_output">
            Current temperature = 51.0F <br/> Max for the month is 68.8F, which occurred at 07-Oct-2009 15:15
        </p>

        <p>
            The format that was used to format the temperature (<span class="code">51.0</span>) is specified in section
            <span class="code"><a href="#Units_StringFormats">[Units][[StringFormat]]</a></span>. The unit label <span
            class="code">F</span> is from section <span class="code"><a
            href="#Units_Labels">[Units][[Labels]]</a></span>, while the time format is from <span class="code"><a
            href="#Units_TimeFormats">[Units][[TimeFormats]]</a></span>.
        </p>

        <p>As we saw above, the tags can be very simple:</p>
        <pre class="tty">## Output max outside temperature using an appropriate format and label:
$month.outTemp.max</pre>
        <p>
            Most of the time, tags will "do the right thing" and are all you will need. However, WeeWX offers extensive
            customization of the generated output for specialized applications such as XML RSS feeds, or rigidly
            formatted reports (such as the NOAA reports). This section specifies the various tag options available.
        </p>

        <p>There are two different versions of the tags, depending on whether the data is "current", or an aggregation
            over time. However, both versions are similar.
        </p>

        <h3>
            Time period <span class="code">$current</span>
        </h3>

        <p>
            Time period <span class="code">$current</span> represents a <em>current observation</em>. An example would
            be the current barometric pressure:
        </p>
        <pre class="tty">$current.barometer</pre>

        <p>
            Formally, WeeWX first looks for the observation type in the record emitted by the <span class="code">NEW_ARCHIVE_RECORD</span>
            event. This is generally the data emitted by the station console, augmented by any derived variables (<i>e.g.</i>
            wind chill) that you might have specified. If the observation type cannot be found there, the most recent
            record in the database will be searched.
        </p>
        <p>The most general tag for a "current" observation looks like:</p>
        <pre class="tty">$current($timestamp=<em>some_time</em>, $max_delta=<em>delta_t</em>,$data_binding=<em>binding_name</em>).<em>obstype</em>[.<em>optional_unit_conversion</em>][.<em>optional_rounding</em>][.<em>optional_formatting</em>]</pre>
        <p>Where:</p>

        <p class="indent">
            <span class="code">some_time</span> is a timestamp that you want to display. It is optional, The default is
            to display the value for the current time.
        </p>

        <p class="indent">
            <span class="code">delta_t</span> is the largest time difference (in seconds) between the time specified and
            a timestamp of a record in the database that will be returned. By default, it is zero, which means there
            must be an exact match with a specified time for a record to be retrieved.
        </p>


        <p class="indent">
            <span class="code">binding_name</span> is a <em>binding name</em> to a database. An example would be <span
            class="code">wx_binding</span>. See the section <em><a href="#binding_names">Binding names</a></em> for more
            details.
        </p>

        <p class="indent">
            <span class="code">obstype</span> is an observation type, such as <span
            class="code">barometer</span>. This type must appear either as a field in the database,
            or in the current (usually, the latest) record.
        </p>

        <p class="indent">
            <span class="code">optional_unit_conversion</span> is an optional unit conversion tag. If provided, the
            results will be converted into the specified units, otherwise the default units specified in the skin
            configuration file (in section <span class="code">[Units][[Groups]]</span>) will be used. See the section
            <em><a href="#unit_conversion_options">Unit conversion options</a></em>.
        </p>

        <p class="indent">
            <span class="code">optional_rounding</span> allows the results to be rounded to a fixed number of decimal
            digits. See the section <em><a href="#optional_rounding">Optional rounding</a></em>
        </p>

        <p class="indent">
            <span class="code">optional_formatting</span> is a set of optional formatting tags, which control how the
            value will appear. See the section <em><a href="#formatting_options">Formatting options</a></em> below.
        </p>

        <h3>
            Time period <span class="code">$latest</span>
        </h3>

        <p>
            Time period <span class="code">$latest</span> is very similar to <span class="code">$current</span>, except
            that it uses the last available timestamp in a database. Usually, <span class="code">$current</span> and
            <span class="code">$latest</span> are the same, but if a data binding points to a remote database, they may
            not be. See the section <em><a href="#stupid_detail">Using multiple bindings</a></em> for an example where
            this happened.
        </p>

        <h3 id="general_aggregation_periods">Aggregation periods</h3>

        <p>Aggregation periods is the other kind of tag. For example,</p>
        <pre class="tty">$week.rain.sum</pre>
        <p>
            represents an <em>aggregation over time</em>, using a certain <em>aggregation type</em>. In this example,
            the aggregation time is a week, and the aggregation type is summation. So, this tag represents the total
            rainfall over a week.
        </p>

        <p>The most general tag for an aggregation over time looks like:</p>
        <pre class="tty">$<em>period</em>($data_binding=<em>binding_name</em>, <em>$optional_ago</em>=<em>delta</em>).<em>statstype</em>.<em>aggregation</em>[.<em>optional_unit_conversion</em>][.<em>optional_rounding</em>][.<em>optional_formatting</em>]
        </pre>
        <p>Where:</p>

        <p class="indent">
            <span class="code"><em>period</em></span> is the time period over which the aggregation is to be done. Possible
            choices are listed in the <a href="#aggregation_periods">table below</a>.
        </p>

        <p class="indent">
            <span class="code"><em>binding_name</em></span> is a <em>binding name</em> to a database. An example would be <span
            class="code">wx_binding</span>. See the section <em><a href="#binding_names">Binding names</a></em> for more
            details.
        </p>

        <p class="indent">
            <span class="code"><em>optional_ago</em></span> is a keyword that depends on the aggregation period. For
            example, for <span class="code">week</span>, it would be <span class="code">weeks_ago</span>, for <span
            class="code">day</span>, it would be <span class="code">days_ago</span>, <i>etc.</i>
        </p>

        <p class="indent">
            <span class="code"><em>delta</em></span> is an integer indicating which aggregation period is desired. For example
            <span class="code">$week($weeks_ago=1)</span> indicates last week, <span
            class="code">$day($days_ago=2)</span> would be the day-before-yesterday, <i>etc</i>. The default is zero:
            that is, this aggregation period.
        </p>

        <p class="indent">
            <span class="code"><em>statstype</em></span> is a <em>statistical type</em>. This is generally any observation type
            that appears in the database, as well as a few synthetic types (such as heating and cooling degree-days).
            Not all aggregations are supported for all types.
        </p>

        <p class="indent">
            <span class="code"><em>aggregation</em></span> is an <em>aggregation type</em>. If you ask for <span class="code">$month.outTemp.avg</span>
            you are asking for the <em>average</em> outside temperature for the month. Possible aggregation types are
            given in <em><a href="#aggregation_types">Appendix: Aggregation types</a></em>.
        </p>

        <p class="indent">
            <span class="code"><em>optional_unit_conversion</em></span> is an optional unit conversion tag. If provided, the
            results will be converted into the specified units, otherwise the default units specified in the skin
            configuration file (in section <span class="code">[Units][[Groups]]</span>) will be used. See the section
            <em><a href="#unit_conversion_options">Unit Conversion Options</a></em>.
        </p>

        <p class="indent">
            <span class="code"><em>optional_rounding</em></span> allows the results to be rounded to a fixed number of decimal
            digits. See the section <em><a href="#optional_rounding">Optional rounding</a></em>
        </p>

        <p class="indent">
            <span class="code"><em>optional_formatting</em></span> is a set of optional formatting tags, which control how the
            value will appear. See the section <em><a href="#formatting_options">Formatting Options</a></em> below.
        </p>

        <p>
            There are several different <em>aggregation periods</em> that can be used:
        </p>
        <table id="aggregation_periods" class="indent" style="width: 80%">
            <caption>Aggregation periods</caption>
            <tbody>
            <tr class="first_row">
                <td>Aggregation period</td>
                <td>Meaning</td>
                <td>Example</td>
                <td>Meaning of example</td>
            </tr>
            <tr>
                <td class="first_col code">$hour</td>
                <td>This hour.</td>
                <td class="code">$hour.outTemp.maxtime</td>
                <td>The time of the max temperature this hour.</td>
            </tr>
            <tr>
                <td class="first_col code">$day</td>
                <td>Today (since midnight).</td>
                <td class="code">$day.outTemp.max</td>
                <td>The max temperature since midnight</td>
            </tr>
            <tr>
                <td class="first_col code">$yesterday</td>
                <td>Yesterday. Synonym for <span class="code">$day($days_ago=1)</span>.
                </td>
                <td class="code">$yesterday.outTemp.maxtime</td>
                <td>The time of the max temperature yesterday.</td>
            </tr>
            <tr>
                <td class="first_col code">$week</td>
                <td>This week. The start of the week is set by option <a href="usersguide.htm#week_start"><span
                    class="code">week_start</span></a>.
                </td>
                <td class="code">$week.outTemp.max</td>
                <td>The max temperature this week.</td>
            </tr>
            <tr>
                <td class="first_col code">$month</td>
                <td>This month (since the first of the month).</td>
                <td class="code">$month.outTemp.min</td>
                <td>The minimum temperature this month.</td>
            </tr>
            <tr>
                <td class="first_col code">$year</td>
                <td>This year (since 1-Jan).</td>
                <td class="code">$year.outTemp.max</td>
                <td>The max temperature since the start of the year.</td>
            </tr>
            <tr>
                <td class="first_col code">$rainyear</td>
                <td>This rain year. The start of the rain year is set by option <a
                    href="usersguide.htm#rain_year_start"><span class="code">rain_year_start</span></a>.
                </td>
                <td class="code">$rainyear.rain.sum</td>
                <td>The total rainfall for this rain year. The start of the rain year is set by option <a
                    href="usersguide.htm#rain_year_start"><span class="code">rain_year_start</span></a>.
                </td>
            </tr>
            <tr>
                <td class="first_col code">$alltime</td>
                <td>
                    All records in the database given by <span class="code"><em>binding_name</em></span>.
                </td>
                <td class="code">$alltime.outTemp.max</td>
                <td>
                    The maximum outside temperature in the default database.
                </td>
            </tr>

            </tbody>
        </table>

        <p>
            The <em>$optional_ago</em> parameters can be useful for statistics farther in the past. Here are some
            examples:
        </p>

        <table class="indent" style="width: 80%">
            <tbody>
            <tr class="first_row">
                <td>Aggregation period</td>
                <td>Example</td>
                <td>Meaning</td>
            </tr>
            <tr>
                <td class="first_col code">$hour($hours_ago=<em>h</em>)
                </td>
                <td class="code">$hour($hours_ago=1).outTemp.avg</td>
                <td>The average temperature last hour (1 hour ago).</td>
            </tr>
            <tr>
                <td class="first_col code">$day($days_ago=<em>d</em>)
                </td>
                <td class="code">$day($days_ago=2).outTemp.avg</td>
                <td>The average temperature day before yesterday (2 days ago).
                </td>
            </tr>
            <tr>
                <td class="first_col code">$week($weeks_ago=<em>d</em>)
                </td>
                <td class="code">$week($weeks_ago=1).outTemp.max</td>
                <td>The maximum temperature last week.</td>
            </tr>
            <tr>
                <td class="first_col code">$month($months_ago=<em>m</em>)
                </td>
                <td class="code">$month($months_ago=1).outTemp.max</td>
                <td>The maximum temperature last month.</td>
            </tr>
            <tr>
                <td class="first_col code">$year($years_ago=<em>m</em>)
                </td>
                <td class="code">$year($years_ago=1).outTemp.max</td>
                <td>The maximum temperature last year.</td>
            </tr>
            </tbody>
        </table>

        <h3 id="unit_conversion_options">Unit conversion options</h3>

        <p>
            The tag <span class="code">optional_unit_conversion</span> can be used with either current observations or
            aggregations. If supplied, the results will be converted to the specified units. For example, if you have
            set <span class="code">group_pressure</span> to inches of mercury (<span class="code">inHg</span>), then the
            tag
        </p>
        <pre class="tty">Today's average pressure=$day.barometer.avg </pre>
        <p>would normally give a result such as</p>

        <p class="example_output">Today's average pressure=30.05 inHg
        </p>

        <p>
            However, if you add <span class="code">mbar</span> to the end of the tag,
        </p>
        <pre class="tty">Today's average pressure=$day.barometer.avg<span class="highlight">.mbar</span></pre>
        <p>then the results will be in millibars:</p>

        <p class="example_output">Today's average pressure=1017.5 mbar
        </p>

        <h4>Illegal conversions</h4>

        <p>
            If an inappropriate or nonsense conversion is asked for, <i>e.g.</i>,
        </p>
        <pre class="tty">Today's minimum pressure in mbars: $day.barometer.min.mbar
or in degrees C: $day.barometer.min.degree_C
or in foobar units: $day.barometer.min.foobar
</pre>
        <p>then the offending tag(s) will be put in the output:</p>

        <p class="example_output">
            Today's minimum pressure in mbars: 1015.3<br/> or in degrees C: $day.barometer.min.degree_C<br/> or in
            foobar units: $day.barometer.min.foobar
        </p>

        <h3 id="optional_rounding">Optional rounding</h3>
        <p>
            The data in the resultant tag can be optionally rounded to a fixed number of decimal digits. This is useful
            when emitting raw data or JSON strings. It should <em>not</em> be used with formatted data (using a
            <a href="#format_string">format string</a> would be a better choice).
        </p>
        <p>
            The structure of the tag is
        </p>
        <pre class="tty">.round(ndigits=None)</pre>
        <p>where</p>
        <p class="indent">
            <span class="code">ndigits</span> is the number of decimal digits to retain. If
            <span class="code">None</span> (the default), then all digits will be retained.
        </p>

        <h3 id="formatting_options">Formatting options</h3>

        <p>
            A variety of tags and arguments are available to you to customize the formatting of the final observation
            value. This table lists the tags:
        </p>
        <table class="indent">
            <caption>Optional formatting tag</caption>
            <tbody>
            <tr class="first_row">
                <td>Optional formatting tag</td>
                <td>Comment</td>
            </tr>
            <tr>
                <td class="code text_highlight">.format(<em>args</em>)</td>
                <td>Format the value as a string, according to a set of optional <em>args</em> (see below).</td>
            </tr>
            <tr>
                <td class="code text_highlight">.ordinal_compass</td>
                <td>Format the value as a compass ordinals (<i>e.g.</i>"SW"), useful for wind directions.
                    The ordinal abbreviations are set by option <span class="code">directions</span> in the skin
                    configuration file <span class="code">skin.conf</span>.
                </td>
            </tr>
            <tr>
                <td class="code text_highlight">.json</td>
                <td>
                    Format the value as a <a href="https://www.json.org/json-en.html">JSON string</a>.
                </td>
            </tr>
            <tr>
                <td class="code text_highlight">.raw</td>
                <td>Return the value "as is", without being converted to a string and without any formatting applied.
                    This can be useful for doing arithmetic directly within the templates. You must be prepared to deal
                    with a potential <span class="code">None</span> value.
                </td>
            </tr>
            </tbody>
        </table>

        <p>The first of these tags (<span class="code">.format()</span>) has the formal structure:</p>
        <pre class="tty">.format(format_string=None, None_string=None, add_label=True, localize=True)</pre>

        <p>Here is the meaning of each of the optional arguments:</p>

        <table class="indent">
            <caption>Optional arguments for <span class="code">.format()</span></caption>
            <tbody>
            <tr class="first_row">
                <td>Optional argument</td>
                <td>Comment</td>
            </tr>
            <tr>
                <td id="format_string" class='code text_highlight'>format_string</td>
                <td>Use the optional string to format the value. If set to <span class="code">None</span>, then an
                    appropriate string format from <span class="code">skin.conf</span> will be used.
                </td>
            </tr>
            <tr>
                <td class="code text_highlight">None_string</td>
                <td>Should the observation value be <span class="code">NONE</span>, then use the supplied string
                    (typically, something like "N/A"). If <span class="code">None_string</span> is set to <span
                        class="code">None</span>, then the value for <span class="code">NONE</span> in <span
                        class="code"> <a href="#Units_StringFormats">[Units][[StringFormats]]</a>
              </span> will be used.
                </td>
            </tr>
            <tr>
                <td class="code text_highlight">add_label</td>
                <td>If set to <span class="code">True</span> (the default), then a unit label (<i>e.g.</i>, &deg;F) from
                    <span class="code">skin.conf</span> will be attached to the end. Otherwise, it will be left out.
                </td>
            </tr>
            <tr>
                <td class="code text_highlight">localize</td>
                <td>If set to <span class="code">True</span> (the default), then localize the results. Otherwise, do
                    not.
                </td>
            </tr>
            </tbody>
        </table>

        <p>If you're willing to honor the ordering of the arguments, the argument name can be omitted.</p>

        <h3>Formatting examples</h3>

        <p>This section gives a number of example tags, and their expected output. The following values are assumed:</p>

        <table class="indent" style="width:50%">
            <caption>Values used in the examples below</caption>
            <tr class="first_row">
                <td>Observation</td>
                <td>Value</td>
            </tr>
            <tr>
                <td class="code first_col">
                    outTemp
                </td>
                <td>45.2&deg;F</td>
            </tr>
            <tr>
                <td class="code first_col">
                    UV
                </td>
                <td>
                    <span class="code">None</span>
                </td>
            </tr>
            <tr>
                <td class="code first_col">
                    windDir
                </td>
                <td>138&deg;</td>
            </tr>
            <tr>
                <td class="code first_col">
                    dateTime
                </td>
                <td>1270250700</td>
            </tr>
        </table>

        <p>Here are the examples:</p>
        <table class="indent">
            <caption>Formatting options with expected results</caption>
            <tbody>
            <tr class="first_row">
                <td>Tag</td>
                <td>Result</td>
                <td>Result<br/>type</td>
                <td>Comment</td>
            </tr>
            <tr>
                <td class="code first_col">$current.outTemp</td>
                <td class="code">45.2F</td>
                <td class="code">str</td>
                <td>
                    String formatting from <span class="code"><a
                    href="#Units_StringFormats">[Units][[StringFormats]]</a></span>. Label from <span class="code"><a
                    href="#Units_Labels">[Units][[Labels]]</a></span>.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.outTemp.format</td>
                <td class="code">45.2F</td>
                <td class="code">str</td>
                <td>
                    Same as the <span class="code">$current.outTemp</span>.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.outTemp.format()</td>
                <td class="code">45.2F</td>
                <td class="code">str</td>
                <td>
                    Same as the <span class="code">$current.outTemp</span>.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.outTemp.format(format_string="%.3f")</td>
                <td class="code">45.200F</td>
                <td class="code">str</td>
                <td>
                    Specified string format used; label from <span class="code"><a href="#Units_Labels">[Units][[Labels]]</a></span>.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.outTemp.format("%.3f")</td>
                <td class="code">45.200F</td>
                <td class="code">str</td>
                <td>
                    As above, except a positional argument, instead of the named argument, is being used.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.outTemp.format(add_label=False)</td>
                <td class="code">45.2</td>
                <td class="code">str</td>
                <td>
                    No label. The string formatting is from <span class="code"><a href="#Units_StringFormats">[Units][[StringFormats]]</a></span>.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.UV</td>
                <td class="code">N/A</td>
                <td class="code">str</td>
                <td>
                    The string specified by option <span class="code">NONE</span> in <span class="code"> <a
                    href="#Units_StringFormats">[Units][[StringFormats]]</a></span>.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.UV.format(None_string="No UV")</td>
                <td class="code">No UV</td>
                <td class="code">str</td>
                <td>
                    Specified <span class="code">None_string</span> is used.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.windDir</td>
                <td class="code">138&deg;</td>
                <td class="code">str</td>
                <td>
                    Formatting is from option <span class="code">degree_compass</span> in <span class="code"> <a
                    href="#Units_StringFormats">[Units][[StringFormats]]</a></span>.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.windDir.ordinal_compass</td>
                <td class="code">SW</td>
                <td class="code">str</td>
                <td>
                    Ordinal direction from section <span class="code"><a
                    href="#Units_Ordinates">[Units][[Ordinates]]</a></span> is being substituted.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.dateTime</td>
                <td class="code">02-Apr-201016:25</td>
                <td class="code">str</td>
                <td>
                    Time formatting from <span class="code"><a
                    href="#Units_TimeFormats">[Units][[TimeFormats]]</a></span> is being used.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.dateTime.format(format_string="%H:%M")</td>
                <td class="code">16:25</td>
                <td class="code">str</td>
                <td>
                    Specified time format used.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.dateTime.format("%H:%M")</td>
                <td class="code">16:25</td>
                <td class="code">str</td>
                <td>
                    As above, except a positional argument, instead of the named argument, is being used.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.dateTime.raw</td>
                <td class="code">1270250700</td>
                <td class="code">int</td>
                <td>
                    Raw Unix epoch time. The result is an <em>integer</em>.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.outTemp.raw</td>
                <td class="code">45.2</td>
                <td class="code">float</td>
                <td>
                    Raw float value. The result is a <em>float</em>.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.outTemp.degree_C.raw</td>
                <td class="code">7.33333333</td>
                <td class="code">float</td>
                <td>
                    Raw float value in degrees Celsius. The result is a <em>float</em>.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.outTemp.degree_C.json</td>
                <td class="code">7.33333333</td>
                <td class="code">str</td>
                <td>
                    Value in degrees Celsius, converted to a JSON string.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$current.outTemp.degree_C.round(2).json</td>
                <td class="code">7.33</td>
                <td class="code">str</td>
                <td>
                    Value in degrees Celsius, rounded to two decimal digits, then converted to a JSON string.
                </td>
            </tr>
            </tbody>
        </table>

        <p>Note that the same formatting conventions can be used for aggregation periods, such as <span class="code">$month</span>,
            as well as <span class="code">$current</span>.
        </p>

        <h3>
            Start, end, and <span class="code">dateTime</span>
        </h3>

        <p>
            While not an observation type, in many ways the time of an observation, <span class="code">dateTime</span>,
            can be treated as one. A tag such as
        </p>
        <pre class="tty">$current.dateTime</pre>
        <p>
            represents the <em>current time</em> (more properly, the time as of the end of the last archive interval)
            and would produce something like
        </p>
        <pre class="example_output">01/09/2010 12:30:00</pre>
        <p>
            Like true observation types, explicit formats can be specified, except that they require a <a
            href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior"> strftime() <em>time
            format</em> </a>, rather than a <em>string format</em>.
        </p>

        <p>For example, adding a format descriptor like this:</p>
        <pre class="tty">$current.dateTime.format("%d-%b-%Y %H:%M")</pre>
        <p>produces</p>

        <p class="example_output">09-Jan-2010 12:30</p>

        <p>
            For <em>aggregation periods</em>, such as <span class="code">$month</span>, you can request the
            <em>start</em> or <em>end</em> of the period, by using suffixes <span class="code">.start</span> or <span
            class="code">.end</span>, respectively. For example,
        </p>
        <pre class="tty">The current month runs from $month.start to $month.end.</pre>
        <p>results in</p>
        <pre class="example_output">The current month runs from 01/01/2010 12:00:00 AM to 02/01/2017 12:00:00 AM.</pre>

        <p>
            In addition to the suffixes <span class="code">.start</span> and <span class="code">.end</span>, the suffix
            <span class="code">.dateTime</span> is provided for backwards compatibility. Like <span
            class="code">.start</span>, it refers to the start of the interval.
        </p>

        <p>
            The returned string values will always be in <em>local time</em>. However, if you ask for the raw value
        </p>
        <pre class="tty">$current.dateTime.raw</pre>

        <p>
            the returned value will be in Unix Epoch Time (number of seconds since 00:00:00 UTC 1 Jan 1970,
            <em>i.e.</em>, a large number), which you must convert yourself. It is guaranteed to never be <span
            class="code">None</span>, so you don't worry have to worry about handling a <span class="code">None</span>
            value.
        </p>


        <h3>
            Tag <span class="code">$trend</span>
        </h3>

        <p>
            The tag <span class="code">$trend</span> is available for time trends, such as changes in barometric
            pressure. Here are some examples:
        </p>
        <table class="indent" style="width: 50%">
            <tbody>
            <tr class="first_row">
                <td>Tag</td>
                <td>Results</td>
            </tr>
            <tr>
                <td class="code first_col">$trend.barometer</td>
                <td class="code">-.05 inHg</td>
            </tr>
            <tr>
                <td class="code first_col">$trend($time_delta=3600).barometer</td>
                <td class="code">-.02 inHg</td>
            </tr>
            <tr>
                <td class="code first_col">$trend.outTemp</td>
                <td class="code">1.1 C</td>
            </tr>
            <tr>
                <td class="code first_col">$trend.time_delta</td>
                <td class="code">10800 secs</td>
            </tr>
            <tr>
                <td class="code first_col">$trend.time_delta.hour</td>
                <td class="code">3 hrs</td>
            </tr>
            </tbody>
        </table>
        <p>
            Note how you can explicitly specify a value in the tag itself (2nd row in the table above). If you do not
            specify a value, then a default time interval, set by option <span class="code"><a
            href="#trend">time_delta</a></span> in the skin configuration file, will be used. This value can be
            retrieved by using the syntax <span class="code">$trend.time_delta</span> (3rd row in the table).
        </p>

        <p>For example, the template expression</p>
        <pre class="tty">The barometer trend over $trend.time_delta.hour is $trend.barometer.format("%+.2f")</pre>
        <p>would result in</p>

        <p class="example_output">The barometer trend over 3 hrs is +.03 inHg.</p>

        <h3>
            Tag <span class="code">$span</span>
        </h3>

        <p>
            The tag <span class="code">$span</span> allows aggregation over a user defined period up to and including
            the current time. Its most general form looks like:
        </p>

        <pre class="tty">$<em>span</em>([data_binding=<em>binding_name</em>][,<em>optional_delta</em>=<em>delta</em>][,boundary=[None|'midnight'])
            .<em>obstype</em>
            .<em>aggregation</em>
            [.<em>optional_unit_conversion</em>]
            [.<em>optional_formatting</em>]</pre>

        <p>Where:</p>
        <p class="indent">
            <em><span class="code">binding_name</span></em> is a <em>binding name</em> to a database. An example would be <span
            class="code">wx_binding</span>. See the section <em><a href="#binding_names">Binding names</a></em> for more
            details.
        </p>

        <p class="indent">
            <span class="code"><em>optional_delta</em>=<em>delta</em></span> is one or more comma separated delta
            settings from the table below. If more than one delta setting is included then the period used for the
            aggregate is the sum of the individual delta settings. If no delta setting is included, or all included
            delta settings are zero, the returned aggregate is based on the current <span class="code">obstype</span>
            only.
        </p>

        <p class="indent">
            <span class="code">boundary</span> is an optional specifier that can force the starting time to a time
            boundary. If set to 'midnight', then the starting time will be at the previous midnight. If left out,
            then the start time will be the sum of the optional deltas.
        </p>

        <p class="indent">
            <em><span class="code">obstype</span></em> is a observation type, such as <span class="code">outTemp</span>.
        </p>

        <p class="indent">
            <em><span class="code">aggregation</span></em> is an <em>aggregation type</em>. Possible aggregation types are given
            in <em><a href="#aggregation_types"> Appendix: Aggregation types</a></em>.
        </p>

        <p class="indent">
            <em><span class="code">optional_unit_conversion</span></em> is an optional unit conversion tag. See the section
            <em><a href="#unit_conversion_options"> Unit conversion options</a></em>.
        </p>

        <p class="indent">
            <em><span class="code">optional_formatting</span></em> is an optional formatting tag that controls how the value will
            appear. See the section <em><a href="#formatting_options">Formatting options</a></em>.
        </p>
        <p>There are several different delta settings that can be used:</p>
        <table class="indent">
            <tbody>
            <tr class="first_row">
                <td>Delta Setting</td>
                <td>Example</td>
                <td>Meaning</td>
            </tr>
            <tr>
                <td class="first_col code">$time_delta=<em>seconds</em></td>
                <td class="code">$span($time_delta=1800).outTemp.avg</td>
                <td>The average temperature over the last immediate 30 minutes (1800 seconds).
                </td>
            </tr>
            <tr>
                <td class="first_col code">$hour_delta=<em>hours</em></td>
                <td class="code">$span($hour_delta=6).outTemp.avg</td>
                <td>The average temperature over the last immediate 6 hours.
                </td>
            </tr>
            <tr>
                <td class="first_col code">$day_delta=<em>days</em></td>
                <td class="code">$span($day_delta=1).rain.sum</td>
                <td>The total rainfall over the last immediate 24 hours.
                </td>
            </tr>
            <tr>
                <td class="first_col code">$week_delta=<em>weeks</em></td>
                <td class="code">$span($week_delta=2).barometer.max</td>
                <td>The maximum barometric pressure over the last immediate 2 weeks.
                </td>
            </tr>
            </tbody>
        </table>

        <p>For example, the template expressions</p>
        <pre class="tty">The total rainfall over the last 30 hours is $span($hour_delta=30).rain.sum</pre>
        <p>and</p>
        <pre class="tty">The total rainfall over the last 30 hours is $span($hour_delta=6, $day_delta=1).rain.sum</pre>
        <p>would both result in</p>

        <p class="example_output">The total rainfall over the last 30 hours is 1.24 in</p>

        <h3>
            Tag <span class="code">$unit</span>
        </h3>

        <p>The type, label, and string formats for all units are also available, allowing you to do highly customized
            labels:
        </p>
        <table class="indent" style="width: 50%">
            <tbody>
            <tr class="first_row">
                <td>Tag</td>
                <td>Results</td>
            </tr>
            <tr>
                <td class="code first_col">$unit.unit_type.outTemp</td>
                <td class="code">degree_C</td>
            </tr>
            <tr>
                <td class="code first_col">$unit.label.outTemp</td>
                <td class="code">C</td>
            </tr>
            <tr>
                <td class="code first_col">$unit.format.outTemp</td>
                <td class="code">%.1f</td>
            </tr>
            </tbody>
        </table>
        <p>For example, the tag</p>
        <pre class="tty">$day.outTemp.max.format(add_label=False)$unit.label.outTemp</pre>
        <p>would result in</p>

        <p class="example_output">21.2C</p>

        <p>
            (assuming metric values have been specified for <span class="code">group_temperature</span>), essentially
            reproducing the results of the simpler tag <span class="code">$day.outTemp.max</span>.
        </p>

        <h3>
            Tag <span class="code">$obs</span>
        </h3>

        <p>
            The labels used for the various observation types are available using tag <span class="code">$obs</span>.
            These are basically the values given in the skin dictionary, section <a href="#Labels_Generic"><span
            class="code">[Labels][[Generic]]</span></a>.
        </p>
        <table class="indent" style="width: 50%">
            <tbody>
            <tr class="first_row">
                <td>Tag</td>
                <td>Results</td>
            </tr>
            <tr>
                <td class="code first_col">$obs.label.outTemp</td>
                <td class="code">Outside Temperature</td>
            </tr>
            <tr>
                <td class="code first_col">$obs.label.UV</td>
                <td class="code">UV Index</td>
            </tr>
            </tbody>
        </table>


        <h3>Iteration</h3>

        <p>It is possible to iterate over the following:</p>

        <table class="indent" style="Width: 90%">
            <tbody>
            <tr class="first_row">
                <td>Tag suffix</td>
                <td>Results</td>
            </tr>
            <tr>
                <td class="code first_col">.records</td>
                <td>Iterate over every record</td>
            </tr>
            <tr>
                <td class="code first_col">.hours</td>
                <td>Iterate by hours</td>
            </tr>
            <tr>
                <td class="code first_col">.days</td>
                <td>Iterate by days</td>
            </tr>
            <tr>
                <td class="code first_col">.months</td>
                <td>Iterate by months</td>
            </tr>
            <tr>
                <td class="code first_col">.years</td>
                <td>Iterate by years</td>
            </tr>
            <tr>
                <td class="code first_col">.spans(interval=<em>seconds</em>)
                </td>
                <td>Iterate by custom length spans. The default interval is 10800 seconds (3 hours). The spans will
                    align to local time boundaries.
                </td>
            </tr>
            </tbody>
        </table>

        <p>
            The following template uses a Cheetah <span class="code">for</span> loop to iterate over all months in a
            year, printing out each month's min and max temperature. The iteration loop is <span class="highlight">&nbsp;highlighted&nbsp;</span>.
        </p>
        <pre class="tty">Min, max temperatures by month
<span class="highlight">#for $month in $year.months</span>
$month.dateTime.format("%B"): Min, max temperatures: $month.outTemp.min $month.outTemp.max
<span class="highlight">#end for</span>
      </pre>
        <p>The result is:</p>

        <p class="example_output">
            Min, max temperatures by month:<br/> January: Min, max temperatures: 30.1F 51.5F<br/> February: Min, max
            temperatures: 24.4F 58.6F<br/> March: Min, max temperatures: 27.3F 64.1F<br/> April: Min, max
            temperatures: 33.2F 52.5F<br/> May: Min, max temperatures: N/A N/A<br/> June: Min, max temperatures: N/A
            N/A<br/> July: Min, max temperatures: N/A N/A<br/> August: Min, max temperatures: N/A N/A<br/> September:
            Min, max temperatures: N/A N/A<br/> October: Min, max temperatures: N/A N/A<br/> November: Min, max
            temperatures: N/A N/A<br/> December: Min, max temperatures: N/A N/A
        </p>

        <p>
            The following template again uses a Cheetah <span class="code">for</span> loop, this time to iterate over
            3-hour spans over the last 24 hours, displaying the averages in each span. The iteration loop is <span
            class="highlight">&nbsp;highlighted&nbsp;</span>.
        </p>
        <pre class="tty">&lt;p&gt;3 hour averages over the last 24 hours&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;Date/time&lt;/td&gt;&lt;td&gt;outTemp&lt;/td&gt;&lt;td&gt;outHumidity&lt;/td&gt;
  &lt;/tr&gt;
<span class="highlight">#for $_span in $span($day_delta=1).spans(interval=10800)</span>
  &lt;tr&gt;
    &lt;td&gt;$_span.start.format("%d/%m %H:%M")&lt;/td&gt;&lt;td&gt;$_span.outTemp.avg&lt;/td&gt;&lt;td&gt;$_span.outHumidity.avg&lt;/td&gt;
  &lt;/tr&gt;
<span class="highlight">#end for</span>
&lt;/table&gt;
</pre>
        <p>The result is:</p>

        <div class="example_output">
            <p>3 hour averages over the last 24 hours</p>
            <table>
                <tr>
                    <td>Date/time</td>
                    <td>outTemp</td>
                    <td>outHumidity</td>
                </tr>
                <tr>
                    <td>21/01 18:50</td>
                    <td>33.4&#176;F</td>
                    <td>95%</td>
                </tr>
                <tr>
                    <td>21/01 21:50</td>
                    <td>32.8&#176;F</td>
                    <td>96%</td>
                </tr>
                <tr>
                    <td>22/01 00:50</td>
                    <td>33.2&#176;F</td>
                    <td>96%</td>
                </tr>
                <tr>
                    <td>22/01 03:50</td>
                    <td>33.2&#176;F</td>
                    <td>96%</td>
                </tr>
                <tr>
                    <td>22/01 06:50</td>
                    <td>33.8&#176;F</td>
                    <td>96%</td>
                </tr>
                <tr>
                    <td>22/01 09:50</td>
                    <td>36.8&#176;F</td>
                    <td>95%</td>
                </tr>
                <tr>
                    <td>22/01 12:50</td>
                    <td>39.4&#176;F</td>
                    <td>91%</td>
                </tr>
                <tr>
                    <td>22/01 15:50</td>
                    <td>35.4&#176;F</td>
                    <td>93%</td>
                </tr>
            </table>

        </div>

        <p>
            See the NOAA template files <span class="code">NOAA/NOAA-YYYY.txt.tmpl</span> and <span class="code">NOAA/NOAA-YYYY-MM.txt.tmpl</span>
            for other examples using iteration, as well as explicit formatting.
        </p>

        <h3>Comprehensive example</h3>
        <p>
            This example is designed to put together a lot of the elements described above, including iteration,
            aggregation period starts and ends, formatting, and overriding units. <a href="examples/tag.htm">Click
            here</a> for the results.
        </p>

        <pre class="tty">
&lt;html&gt;
  &lt;head&gt;
    &lt;style&gt;
      td { border: 1px solid #cccccc; padding: 5px; }
    &lt;/style&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;table border=1 style="border-collapse:collapse;"&gt;
      &lt;tr style="font-weight:bold"&gt;
        &lt;td&gt;Time interval&lt;/td&gt;
        &lt;td&gt;Max temperature&lt;/td&gt;
        &lt;td&gt;Time&lt;/td&gt;
      &lt;/tr&gt;
#for $hour in $day($days_ago=1).hours
      &lt;tr&gt;
        &lt;td&gt;$hour.start.format("%H:%M")-$hour.end.format("%H:%M")&lt;/td&gt;
        &lt;td&gt;$hour.outTemp.max ($hour.outTemp.max.degree_C)&lt;/td&gt;
        &lt;td&gt;$hour.outTemp.maxtime.format("%H:%M")&lt;/td&gt;
      &lt;/tr&gt;
#end for
      &lt;caption&gt;
        &lt;p&gt;
          Hourly max temperatures yesterday&lt;br/&gt;
          $day($days_ago=1).start.format("%d-%b-%Y")
        &lt;/p&gt;
      &lt;/caption&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
        <h3>Helper functions</h3>
        <p>
            WeeWX includes a number of helper functions that may be useful when writing templates.
        </p>
        <table class="indent">
            <caption>Cheetah helper functions</caption>
            <tbody>
            <tr class="first_row">
                <td>Function</td>
                <td>Description</td>
            </tr>
            <tr>
                <td class="first_col code">$rnd(x, ndigits=None)</td>
                <td>
                    Round <span class="code">x</span> to <span class="code">ndigits</span> decimal digits. The argument
                    <span class="code">x</span> can be a <span class="code">float</span> or a list of <span
                    class="code">floats</span>. Values of <span class="code">None</span> are passed through.
                </td>
            </tr>
            <tr>
                <td class="first_col code">$jsonize(seq)</td>
                <td>Convert the iterable <span class="code">seq</span> to a JSON string.</td>
            </tr>
            <tr>
                <td class="first_col code">$to_int(x)</td>
                <td>
                    Convert <span class="code">x</span> to an integer. The argument <span class="code">x</span> can be
                    of type <span class="code">float</span> or <span class="code">str</span>. Values of <span
                    class="code">None</span> are passed through.
                </td>
            </tr>
            <tr>
                <td class="first_col code">$getobs(plot_name)</td>
                <td>
                    For a given plot name, this function will return the set of all observation types used by the plot.
                    <a href="#getobs-more-info">More information.</a>
                <div id="getobs-more-info" class="modal-dialog">
                    <div>
                        <a href="#close" title="Close" class="close-dialog">X</a>
                        <p>
                            For example, consider a plot that is defined in <span class="code">[ImageGenerator]</span> as
                        </p>
                        <pre class="tty">    [[[daytempleaf]]]
        [[[[leafTemp1]]]]
        [[[[leafTemp2]]]]
        [[[[temperature]]]]
            data_type = outTemp
</pre>
                        <p>The tag <span class="code">$getobs('daytempleaf')</span> would return the
                        set <span class="code">{'leafTemp1', 'leafTemp2', 'outTemp'}</span>.</p>
                    </div>
                </div>
                </td>
            </tr>
            </tbody>
        </table>

        <h3>Support for series</h3>
        <p class="warning">
            This is an experimental API that could change.
        </p>
        <p>
            WeeWX V4.5 introduced some experimental tags for producing <em>series</em> of data, possibly aggregated.
            This can be useful for
            creating the JSON data needed for JavaScript plotting packages, such
            as <a href="https://www.highcharts.com/">HighCharts</a>,
            <a href="https://developers.google.com/chart">Google Charts</a>,
            or <a href="https://c3js.org/">C3.js</a>.
        </p>
        <p>
            For example, suppose you need the maximum temperature for each day of the month. This tag
        </p>
        <pre>
$month.outTemp.series(aggregate_type='max', aggregate_interval='day', time_series='start').json
        </pre>
        <p>
            would produce the following:
        </p>
        <pre>
[[1614585600, 58.2], [1614672000, 55.8], [1614758400, 59.6], [1614844800, 57.8], ... ]
        </pre>
        <p>
            This is a list of (time, temperature) for each day of the month, in JSON, easily consumed by many of these
            plotting packages.
        </p>
        <p>
            Many other combinations are possible. See the Wiki article
            <a href="https://github.com/weewx/weewx/wiki/Tags-for-series"><em>Tags for series</em></a>.
        </p>

        <h3>General tags</h3>

        <p>
            There are some general tags that do not reflect observation data, but technical information about the
            template files. They are frequently useful in <span class="code">#if</span> expressions to control how
            Cheetah processes the template.
        </p>
        <table class="indent">
          <tbody>
            <tr class="first_row">
              <td>Tag</td>
              <td>Description</td>
            </tr>
            <tr>
              <td class="code first_col">$encoding</td>
              <td>Character encoding, to which the file is converted
              after creation. Possible values are
              <span class="code">html_entities</span>,
              <span class="code">strict_ascii</span>,
              <span class="code">normalized_ascii</span>, and
              <span class="code">utf-8</span>.
              </td>
            </tr>
            <tr>
              <td class="code first_col">$filename</td>
              <td>
                Name of the file to be created including relative path.
                Can be used to set the canonical URL for search engines.
                <pre class="tty">&lt;link rel="canonical" href="$station.station_url/$filename" /&gt;</pre>
              </td>
            </tr>
            <tr>
                <td class="code first_col">$lang</td>
                <td>Language code set by the <span class="code">lang</span> option for the report. For example,
                    <span class="code">fr</span>, or <span class="code">gr</span>.
                </td>
            </tr>
            <tr>
              <td class="code first_col">$month_name</td>
              <td>For templates listed under <span class="code">SummaryByMonth</span>, this will contain the localized
                  month name (<em>e.g.</em>, "<em>Sep</em>").</td>
            </tr>
            <tr>
                <td class="code first_col">$page</td>
                <td>The section name from <span class="code">skin.conf</span> where the template is described.</td>
            </tr>
            <tr>
                <td class="code first_col">$skin</td>
                <td>The value of option <span class="code">skin</span> in <span class="code">weewx.conf</span>.</td>
            </tr>
            <tr>
                <td class="code first_col">$SKIN_NAME</td>
                <td>
                    All skin included with WeeWX, version 4.6 or later, include the tag
                    <span class="code">$SKIN_NAME</span>. For example, for
                    the <em>Seasons</em> skin, <span class="code">$SKIN_NAME</span> would return
                    <span class="code">Seasons</span>.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$SKIN_VERSION</td>
                <td>
                    All skin included with WeeWX, version 4.6 or later, include the tag
                    <span class="code">$SKIN_VERSION</span>, which returns the WeeWX version number of when the skin was
                    installed. Because skins are not touched during the upgrade process, this shows the origin of the
                    skin.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$SummaryByDay</td>
                <td>
                    A list of year-month-day strings (<em>e.g.</em>, <span class="code">["2018-12-31", "2019-01-01"]</span>)
                    for which a summary-by-day has been generated.
                    The <span class="code">[[SummaryByDay]]</span> section must have been processed before this tag
                    will be valid, otherwise it will be empty.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$SummaryByMonth</td>
                <td>
                    A list of year-month strings (<em>e.g.</em>, <span class="code">["2018-12", "2019-01"]</span>)
                    for which a summary-by-month has been generated.
                    The <span class="code">[[SummaryByMonth]]</span> section must have been processed before this tag
                    will be valid, otherwise it will be empty.
                </td>
            </tr>
            <tr>
                <td class="code first_col">$SummaryByYear</td>
                <td>
                    A list of year strings (<em>e.g.</em>, <span class="code">["2018", "2019"]</span>)
                    for which a summary-by-year has been generated.
                    The <span class="code">[[SummaryByYear]]</span> section must have been processed before this tag
                    will be valid, otherwise it will be empty.
                </td>
            </tr>            
            <tr>
              <td class="code first_col">$year_name</td>
                <td>For templates listed under <span class="code">SummaryByMonth</span> or
                    <span class="code">SummaryByYear</span>, this will contain the year (<em>e.g.</em>, "2018").</td>
            </tr>
          </tbody>
        </table>


        <h3 id="Tag_$gettext">
          Internationalization support with <span class="code">$gettext</span>
        </h3>
        <p>
            Pages generated by WeeWX not only contain observation data, but also static text. The WeeWX
            <span class="code">$gettext</span>
            tag provides internationalization support for these kinds of texts. It is structured very similarly to the <a
            href="https://www.gnu.org/software/gettext/">GNU gettext facility</a>, but its implementation is very
            different. To support internationalization of your template, do not use static text in your templates, but
            rather use <span class="code">$gettext</span>. Here's how.
        </p>
        <p>
            Suppose you write a skin called "<span class="code">YourSkin</span>", and you want to include a headline
            labelled "Current Conditions" in English, "aktuelle Werte" in German, "Conditions actuelles" in French,
            etc. Then the template file could contain:
        </p>
        <pre class="tty">...

&lt;h1&gt;$gettext("Current Conditions")&lt;/h1&gt;

...</pre>
        <p>
          The section of <span class="code">weewx.conf</span> configuring your skin would look something like this:
        </p>
        <pre class="tty">...
[StdReport]
    ...
    [[YourSkinReport]]
        skin = YourSkin
        lang = fr
    ...</pre>
        <p>
          With <span class="code">lang = fr</span> the report
          is in French. To get it in English, replace the language
          code <span class="code">fr</span> by the code for English
          <span class="code">en</span>. And to get it in German
          use <span class="code">de</span>.
        </p>
        <p>
            To make this all work a language file has to be created for each supported language. The language files
            reside in the <span class="code">lang</span> subdirectory of the skin directory that is defined by the <span
            class="code">skin</span> option. The file name of the language file is the language code appended by <span
            class="code">.conf</span>, for example <span class="code">en.conf</span>, <span class="code">de.conf</span>,
            or <span class="code">fr.conf</span>.
        </p>
        <p>
          The language file has the same layout as
          <span class="code">skin.conf</span>, i.e.
          you can put language specific versions of the labels there.
          Additionally a section <span class="code">[Texts]</span>
          can be defined to hold the static texts used in the skin.
          For the example above the language files would contain
          the following:
        </p>
        <p class="code">en.conf</p>
        <pre class="tty">...
[Texts]
    "Current Conditions" = Current Conditions
    ...</pre>
        <p class="code">de.conf</p>
        <pre class="tty">...
[Texts]
    "Current Conditions" = Aktuelle Werte
    ...</pre>
        <p class="code">fr.conf</p>
        <pre class="tty">...
[Texts]
    "Current Conditions" = Conditions actuelles
    ...</pre>
        <p>
            While it is not technically necessary, we recommend using the whole English text for the key. This makes the
            template easier to read, and easier for the translator. In the absence of a translation, it will also
            be the default, so the skin will still be usable, even if a translation is not available.
        </p>
        <p>
          See the subdirectory <span class="symcode">SKIN_ROOT</span><span class="code">/Seasons/lang</span>
          for examples of language files.
        </p>

        <h4 id="Tag_$pgettext">
          Context sensitive lookups: <span class="code">$pgettext()</span>
        </h4>
        <p>
            A common problem is that the same string may have different translations, depending on its context. For
            example, in English, the word "Altitude" is used to mean both height above sea level, and the angle of a
            heavenly body from the horizon, but that's not necessarily true in other languages. For example, in Thai,
            "" is used to mean the former, "" the latter. The function <span
            class="code">pgettext()</span> (the "p" stands for <em>particular</em>) allows you to distinguish between
            the two. Its semantics are very similar to the <a
            href="https://www.gnu.org/software/gettext/manual/gettext.html#Contexts">GNU</a> and <a
            href="https://docs.python.org/3/library/gettext.html#gettext.pgettext">Python</a> versions of the function.
            Here's an example:
        </p>

        <pre>
            &lt;p&gt;$pgettext("Geographical","Altitude"): $station.altitude&lt;/p&gt;
            &lt;p&gt;$pgettext("Astronomical","Altitude"): $almanac.moon.alt&lt;/p&gt;
        </pre>

        <p>
            The <span class="code">[Texts]</span> section of the language file should then contain a subsection for each context. For
            example, the Thai language file would include:
        </p>
        <pre>
[Texts]
    ...
    [[Geographical]]
        "Altitude" = ""    # As in height above sea level
    [[Astronomical]]
        "Altitude" = ""         # As in angle above the horizon
    ...
        </pre>


        <h2>Almanac</h2>

        <p>
            If module <a href="https://rhodesmill.org/pyephem">pyephem</a> has been installed, then WeeWX can generate
            extensive almanac information for the Sun, Moon, Venus, Mars, Jupiter, and other heavenly bodies, including
            their rise, transit and set times, as well as their azimuth and altitude. Other information is also
            available.
        </p>

        <p>Here is an example template:</p>

        <pre class="tty">Current time is $current.dateTime
#if $almanac.hasExtras
Sunrise, transit, sunset: $almanac.sun.rise $almanac.sun.transit $almanac.sun.set
Moonrise, transit, moonset: $almanac.moon.rise $almanac.moon.transit $almanac.moon.set
Mars rise, transit, set: $almanac.mars.rise $almanac.mars.transit $almanac.mars.set
Azimuth, altitude of mars: $almanac.mars.az $almanac.mars.alt
Next new, full moon: $almanac.next_new_moon $almanac.next_full_moon
Next summer, winter solstice: $almanac.next_summer_solstice $almanac.next_winter_solstice
#else
Sunrise, sunset: $almanac.sunrise $almanac.sunset
#end if</pre>

        <p>If pyephem is installed this would result in:</p>

        <p class="example_output">
            Current time is 29-Mar-2011 09:20<br/> Sunrise, transit, sunset: 06:51 13:11 19:30<br/> Moonrise, transit,
            moonset: 04:33 09:44 15:04<br/> Mars rise, transit, set: 06:35 12:30 18:26<br/> Azimuth, altitude of mars:
            124.354959275 26.4808431952<br/> Next new, full moon: 03-Apr-2011 07:32 17-Apr-2011 19:43<br/> Next summer,
            winter solstice: 21-Jun-2011 10:16 21-Dec-2011 21:29
        </p>

        <p>Otherwise, a fallback of basic calculations is used, resulting in:</p>

        <p class="example_output">
            Current time is 29-Mar-2011 09:20<br/> Sunrise, sunset: 06:51 19:30
        </p>

        <p>
            As shown in the example, you can test whether this extended almanac information is available with the value
            <span class="code">$almanac.hasExtras</span>.
        </p>

        <p>The almanac information falls into three categories:</p>
        <ul>
            <li>Calendar events</li>
            <li>Heavenly bodies</li>
            <li>Functions</li>
        </ul>
        <p>We will cover each of these separately.</p>
        <h3>Calendar events</h3>

        <p>
            "Calendar events" do not require a heavenly body. They cover things such as <span
            class="code">next_solstice</span>, <span class="code">next_first_quarter_moon</span> or <span class="code">sidereal_time</span>.
            The syntax here is:
        </p>
        <pre class="tty">$almanac.next_solstice</pre>
        <p>or</p>
        <pre class="tty">$almanac.next_first_quarter_moon</pre>
        <p>or</p>
        <pre class="tty">$almanac.sidereal_time</pre>
        <p>Here is a table of the information that falls into this category:</p>
        <table class="indent" style="width: 60%">
            <caption>Calendar events</caption>
            <tbody class="code">
            <tr>
                <td>previous_equinox</td>
                <td>next_equinox</td>
                <td>previous_solstice</td>
                <td>next_solstice</td>
            </tr>
            <tr>
                <td>previous_autumnal_equinox</td>
                <td>next_autumnal_equinox</td>
                <td>previous_vernal_equinox</td>
                <td>next_vernal_equinox</td>
            </tr>
            <tr>
                <td>previous_winter_solstice</td>
                <td>next_winter_solstice</td>
                <td>previous_summer_solstice</td>
                <td>next_summer_solstice</td>
            </tr>
            <tr>
                <td>previous_new_moon</td>
                <td>next_new_moon</td>
                <td>previous_first_quarter_moon</td>
                <td>next_first_quarter_moon</td>
            </tr>
            <tr>
                <td>previous_full_moon</td>
                <td>next_full_moon</td>
                <td>previous_last_quarter_moon</td>
                <td>next_last_quarter_moon</td>
            </tr>
            <tr>
                <td>sidereal_time</td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            </tbody>
        </table>

        <p class="note" style="display: inline-block">
            <strong>Note</strong><br/>The tag <span class="code">$almanac.sidereal_time</span> returns a value in
            decimal degrees rather than a customary value from 0 to 24 hours.
        </p>

        <h3>Heavenly bodies</h3>

        <p>The second category does require a heavenly body. This covers queries such as, "When does Jupiter rise?" or,
            "When does the sun transit?" Examples are
        </p>
        <pre class="tty">$almanac.jupiter.rise</pre>
        <p>or</p>
        <pre class="tty">$almanac.sun.transit</pre>
        <p>
            To accurately calculate these times, WeeWX automatically uses the present temperature and pressure to
            calculate refraction effects. However, you can override these values, which will be necessary if you wish to
            match the almanac times published by the Naval Observatory <a
            href="https://rhodesmill.org/pyephem/rise-set.html">as explained in the pyephem documentation</a>. For
            example, to match the sunrise time as published by the Observatory, instead of
        </p>
        <pre class="tty">$almanac.sun.rise</pre>
        <p>use</p>
        <pre class="tty">$almanac(pressure=0, horizon=-34.0/60.0).sun.rise</pre>
        <p>By setting pressure to zero we are bypassing the refraction calculations and manually setting the horizon to
            be 34 arcminutes lower than the normal horizon. This is what the Navy uses.
        </p>

        <p>
            If you wish to calculate the start of civil twilight, you can set the horizon to -6 degrees, and also tell
            WeeWX to use the center of the sun (instead of the upper limb, which it normally uses) to do the calcuation:
        </p>
        <pre class="tty">$almanac(pressure=0, horizon=-6).sun(use_center=1).rise</pre>
        <p>The general syntax is:</p>
        <pre class="tty">$almanac(almanac_time=<em>time</em>,            ## Unix epoch time
         lat=<em>latitude</em>, lon=<em>longitude</em>,  ## degrees
         altitude=<em>altitude</em>,            ## meters
         pressure=<em>pressure</em>,            ## mbars
         horizon=<em>horizon</em>,              ## degrees
         temperature=<em>temperature_C</em>     ## degrees C
       ).<em>heavenly_body</em>(use_center=[01]).<em>attribute</em>
      </pre>
        <p>
            As you can see, many other properties can be overridden besides pressure and the horizon angle.
        </p>

        <p>
            PyEphem offers an extensive list of objects that can be used for the <span
            class="code"><em>heavenly_body</em></span> tag. All the planets and many stars are in the list.
        </p>

        <p>
            The possible values for the <span class="code">attribute</span> tag are listed in the following table:
        </p>
        <table class="indent" style="width: 80%">
            <caption>Attributes that can be used with heavenly bodies
            </caption>
            <tbody class="code">
            <tr>
                <td>az</td>
                <td>alt</td>
                <td>a_ra</td>
                <td>a_dec</td>
            </tr>
            <tr>
                <td>g_ra</td>
                <td>ra</td>
                <td>g_dec</td>
                <td>dec</td>
            </tr>
            <tr>
                <td>elong</td>
                <td>radius</td>
                <td>hlong</td>
                <td>hlat</td>
            </tr>
            <tr>
                <td>sublat</td>
                <td>sublong</td>
                <td>next_rising</td>
                <td>next_setting</td>
            </tr>
            <tr>
                <td>next_transit</td>
                <td>next_antitransit</td>
                <td>previous_rising</td>
                <td>previous_setting</td>
            </tr>
            <tr>
                <td>previous_transit</td>
                <td>previous_antitransit</td>
                <td>rise</td>
                <td>set</td>
            </tr>
            <tr>
                <td>transit</td>
                <td>visible</td>
                <td>visible_change</td>
                <td></td>
            </tr>
            </tbody>
        </table>

        <p class="note" style="display: inline-block">
            <strong>Note</strong><br/>The tags <span class="code">ra</span>, <span class="code">a_ra</span> and <span
            class="code">g_ra</span> return values in decimal degrees rather than customary values from 0 to 24 hours.
        </p>

        <h3>Functions</h3>
        <p>There is actually one one function in this category: <span class="code">separation</span>. It returns the
            angular separation between two heavenly bodies. For example, to calculate the angular separation between
            Venus and Mars you would use:
        </p>
        <pre class="tty">
&lt;p&gt;The separation between Venus and Mars is
      $almanac.separation(($almanac.venus.alt,$almanac.venus.az), ($almanac.mars.alt,$almanac.mars.az))&lt;/p&gt;
     </pre>
        <p>This would result in:</p>
        <p class="example_output">The separation between Venus and Mars is 55:55:31.8</p>

        <h3>Adding new bodies to the almanac</h3>
        <p>
            It is possible to extend the WeeWX almanac, adding new bodies that it was not previously aware of. For
            example, say we wanted to add <a href="https://en.wikipedia.org/wiki/433_Eros"><em>433 Eros</em></a>, the
            first asteroid visited by a spacecraft. Here is the process:
        </p>
        <ol>

            <li>
                Put the following in the file <span class="code">user/extensions.py</span>:
                <pre class="tty">import ephem
eros = ephem.readdb("433 Eros,e,10.8276,304.3222,178.8165,1.457940,0.5598795,0.22258902,71.2803,09/04.0/2017,2000,H11.16,0.46")
ephem.Eros = eros</pre>
                This does two things: it adds orbital information about <em>433 Eros</em> to the internal pyephem
                database, and it makes that data available under the name <span class="code">Eros</span> (note the
                capital letter).
            </li>

            <li>
                You can then use <em>433 Eros</em> like any other body in your templates. For example, to display when
                it will rise above the horizon:

                <pre class="tty">$almanac.eros.rise</pre>

            </li>
        </ol>

        <h2>Wind</h2>

        <p>
            Wind deserves a few comments because it is stored in the database in two different ways: as a set of
            scalars, and as a <em>vector</em> of speed and direction. Here are the four wind-related scalars stored in
            the main archive database:
        </p>
        <table class="indent">
            <tbody>
            <tr class="first_row">
                <td>Archive type</td>
                <td>Meaning</td>
                <td>Valid contexts</td>
            </tr>
            <tr>
                <td class="first_col code">windSpeed</td>
                <td>The average wind speed seen during the archive period.
                </td>
                <td rowspan='4' class='code'>
                    $current, $latest, $hour, $day, $week, $month, $year, $rainyear
                </td>
            </tr>
            <tr>
                <td class="first_col code">windDir</td>
                <td>If software record generation is used, this is the vector average over the archive period. If
                    hardware record generation is used, the value is hardware dependent.
                </td>
            </tr>
            <tr>
                <td class="first_col code">windGust</td>
                <td>The maximum (gust) wind speed seen during the archive period.
                </td>
            </tr>
            <tr>
                <td class="first_col code">windGustDir</td>
                <td>The direction of the wind when the gust was observed.</td>
            </tr>
            </tbody>
        </table>

        <p>
            Some wind aggregation types, notably <span class="code">vecdir</span> and <span class="code">vecavg</span>,
            require wind speed <em>and</em> direction. For these, WeeWX provides a composite observation type
            called <span class="code">wind</span>. It is stored directly in the daily summaries, but synthesized for
            aggregations other than multiples of a day.
        </p>
        <table class="indent">
            <tbody>
            <tr class="first_row">
                <td>Daily&nbsp;summary&nbsp;type</td>
                <td>Meaning</td>
                <td>Valid contexts</td>
            </tr>
            <tr>
                <td class="first_col code">wind</td>
                <td>A vector composite of the wind.</td>
                <td class='code'>$hour, $day, $week, $month, $year, $rainyear</td>
            </tr>
            </tbody>
        </table>

        <p>Any of these can be used in your tags. Here are some examples:</p>

        <table class="indent" style="width: 90%;">
            <tbody>
            <tr class="first_row">
                <td>Tag</td>
                <td>Meaning</td>
            </tr>
            <tr>
                <td class="first_col code">$current.windSpeed</td>
                <td>The average wind speed over the most recent archive interval.
                </td>
            </tr>
            <tr>
                <td class="first_col code">$current.windDir</td>
                <td>If software record generation is used, this is the vector average over the archive interval. If
                    hardware record generation is used, the value is hardware dependent.
                </td>
            </tr>
            <tr>
                <td class="first_col code">$current.windGust</td>
                <td>The maximum wind speed (gust) over the most recent archive interval.
                </td>
            </tr>
            <tr>
                <td class="first_col code">$current.windGustDir</td>
                <td>The direction of the gust.</td>
            </tr>
            <tr>
                <td class="first_col code">$day.windSpeed.avg<br/>$day.wind.avg</td>
                <td>The average wind speed since midnight. If the wind blows east at 5 m/s for 2 hours, then west at 5
                    m/s for 2 hours, the average wind speed is 5 m/s.
                </td>
            </tr>
            <tr>
                <td class="first_col code">$day.wind.vecavg</td>
                <td>The <em>vector average</em> wind speed since midnight. If the wind blows east at 5 m/s for 2 hours,
                    then west at 5 m/s for 2 hours, the vector average wind speed is zero.
                </td>
            </tr>
            <tr>
                <td class="first_col code">$day.wind.vecdir</td>
                <td>The direction of the vector averaged wind speed. If the wind blows northwest at 5 m/s for two hours,
                    then southwest at 5 m/s for two hours, the vector averaged direction is west.
                </td>
            </tr>
            <tr>
                <td class="first_col code">$day.windGust.max<br/>$day.wind.max</td>
                <td>The maximum wind gust since midnight.</td>
            </tr>
            <tr>
                <td class="first_col code">$day.wind.gustdir</td>
                <td>The direction of the maximum wind gust.</td>
            </tr>
            <tr>
                <td class="first_col code">$day.windGust.maxtime<br/>$day.wind.maxtime</td>
                <td>The time of the maximum wind gust.</td>
            </tr>
            <tr>
                <td class="first_col code">$day.windSpeed.max</td>
                <td>The max average wind speed. The wind is averaged over each of the archive intervals. Then the
                    maximum of these values is taken. Note that this is <em>not</em> the same as the maximum wind gust.
                </td>
            </tr>
            <tr>
                <td class="first_col code">$day.windDir.avg</td>
                <td>
                    Not a very useful quantity. This is the strict, arithmetic average of all the compass wind
                    directions. If the wind blows at 350&deg; for two hours then at 10&deg; for two hours,
                    then the scalar average wind direction will be 180&deg; &mdash; probably not what you
                    expect, nor want.
                </td>
            </tr>
            </tbody>
        </table>


        <h2 id="defining_new_tags">Defining new tags</h2>

        <p>
            We have seen how you can change a template and make use of the various tags available such as <span
            class="code">$day.outTemp.max</span> for the maximum outside temperature for the day. But, what if you want
            to introduce some new data for which no tag is available?
        </p>

        <p>
            If you wish to introduce a static tag, that is, one that will not change with time (such as a Google
            analytics Tracker ID, or your name), then this is very easy: simply put it in section <span class="code"><a
            href="#Extras">[Extras]</a></span> in the skin configuration file. More information on how to do this can be
            found there.
        </p>

        <p>
            But, what if you wish to introduce a more dynamic tag, one that requires some calculation, or perhaps uses
            the database? Simply putting it in the <span class="code">[Extras]</span> section won't do, because then it
            cannot change.
        </p>

        <p>
            The answer is to write a <em>search list extension</em>. Complete directioins on how to do this are in
            a companion document <a href="sle.html"><em>Writing search list extensions</em></a>.
        </p>


        <!-- -------------------------------------------------------------- -->

        <h1 id="image_generator">The Image generator</h1>

        <p class="note">
            This section gives an overview of the Image generator. For details about each of its various options, see
            the section <a href="#ImageGenerator"><em>[ImageGenerator]</em></a> in the <a href="#report_options"><em>Reference:
            report options</em></a>.
        </p>

        <p>
            The installed version of WeeWX is configured to generate a set of useful plots. But, what if you don't like
            how they look, or you want to generate different plots, perhaps with different aggregation types? This
            section covers how to do this.
        </p>

        <p>
            Image generation is controlled by the section <a href="#ImageGenerator"><span
            class="code">[ImageGenerator]</span></a> in the skin configuration file <span class="code">skin.conf</span>.
            Let's take a look at the beginning part of this section. It looks like this:
        </p>
        <pre class="tty">[ImageGenerator]
    ...
    image_width = 500
    image_height = 180
    image_background_color = #f5f5f5

    chart_background_color = #d8d8d8
    chart_gridline_color = #a0a0a0
    ...</pre>
        <p>
            The options right under the section name <span class="code">[ImageGenerator]</span> will apply to
            <em>all</em> plots, unless overridden in subsections. So, unless otherwise changed, all plots will be 500
            pixels in width, 180 pixels in height, and will have an RGB background color of #f5f5f5, a very light gray
            (HTML color "WhiteSmoke"). The chart itself will have a background color of #d8d8d8 (a little darker gray),
            and the gridlines will be #a0a0a0 (still darker). The other options farther down (not shown) will also apply
            to all plots.
        </p>

        <h2>Time periods</h2>

        <p>
            After the "global" options at the top of section <span class="code">[ImageGenerator]</span>, comes a set of
            sub-sections, one for each time period (day, week, month, and year). These sub-sections define the nature of
            aggregation and plot types for that time period. For example, here is a typical set of options for
            sub-section <span class="code">[[month_images]]</span>. It controls which "monthly" images will get
            generated, and what they will look like:
        </p>
        <pre class="tty">    [[month_images]]
        x_label_format = %d
        bottom_label_format = %m/%d/%y %H:%M
        time_length = 2592000    # == 30 days
        aggregate_type = avg
        aggregate_interval = 10800    # == 3 hours
        show_daynight = false
</pre>
        <p>
            The option <span class="code">x_label_format</span> gives a <a
            href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior">strftime()</a> type format
            for the x-axis. In this example, it will only show days (format option <span class="code">%d</span>). The
            <span class="code">bottom_label_format</span> is the format used to time stamp the image at the bottom. In
            this example, it will show the time as something like <span class="code">10/25/09
          15:35</span>. A plot will cover a nominal 30 days, and all items included in it will use an aggregate type of
            averaging over 3 hours. Finally, by setting option <span class="code">show_daynight</span> to <span
            class="code">false</span>, we are requesting that day-night, shaded bands not be shown.
        </p>

        <h2>Image files</h2>

        <p>
            Within each time period sub-section is another nesting, one for each image to be generated. The title of
            each sub-sub-section is the filename to be used for the image. Finally, at one additional nesting level (!)
            are the logical names of all the line types to be drawn in the image. Like elsewhere, the values specified
            in the level above can be overridden. For example, here is a typical set of options for sub-sub-section
            <span class="code">[[[monthrain]]]</span>:
        </p>
        <pre class="tty">        [[[monthrain]]]
            plot_type = bar
            yscale = None, None, 0.02
            [[[[rain]]]]
                aggregate_type = sum
                aggregate_interval = day
                label = Rain (daily total)</pre>
        <p>
            This will generate an image file with name <span class="code">monthrain.png</span>. It will be a bar plot.
            Option <span class="code">yscale</span> controls the y-axis scaling &mdash; if left out, the scale will
            automatically be chosen. However, in this example we are choosing to exercise some degree of control by
            specifying values explicitly. The option is a 3-way tuple (<span class="code">ylow</span>, <span
            class="code">yhigh</span>, <span class="code">min_interval</span>), where <span class="code">ylow</span> and
            <span class="code">yhigh</span> are the minimum and maximum y-axis values, respectively, and <span
            class="code">min_interval</span> is the minimum tick interval. If set to <span class="code">None</span>, the
            corresponding value will be automatically chosen. So, in this example, the setting
        </p>
        <pre class="tty">yscale = None, None, 0.02</pre>
        <p>
            will cause WeeWX to pick sensible y minimum and maximum values, but require that the tick increment (<span
            class="code">min_interval</span>) be at least 0.02.
        </p>

        <p>
            Continuing on with the example above, there will be only one plot "line" (it will actually be a series of
            bars) and it will have logical name <span class="code">rain</span>. Because we have not said otherwise, the
            database column name to be used for this line will be the same as its logical name, that is, <span
            class="code">rain</span>, but this can be overridden. The aggregation type will be summing (overriding the
            averaging specified in sub-section <span class="code">[[month_images]]</span>), so you get the total rain
            over the aggregate period (rather than the average) over an aggregation interval of 86,400 seconds (one
            day). The plot line will be titled with the indicated label of 'Rain (daily total)'. The result of all this
            is the following plot:
        </p>

        <p>
            <img src="images/sample_monthrain.png" alt="Sample monthly rain plot"/>
        </p>

        <h2>Including more than one type in a plot</h2>

        <p>More than one observation can be included in a plot. For example, here is how to generate a plot with the
            week's outside temperature as well as dewpoint:
        </p>
        <pre class="tty">[[[monthtempdew]]]
    [[[[outTemp]]]]
    [[[[dewpoint]]]]</pre>
        <p>
            This would create an image in file <span class="code">monthtempdew.png</span> that includes a line plot of
            both outside temperature and dewpoint:
        </p>
        <p>
            <img src="images/sample_monthtempdew.png" alt="Monthly temperature and dewpoint"/>
        </p>

        <h3 id="including_same_sql_type_2x">Including a type more than once in a plot</h3>

        <p>
            Another example. Say you want a plot of the day's temperature, overlaid with hourly averages. Here, you are
            using the same data type (<span class="code">outTemp</span>) for both plot lines, the first with averages,
            the second without. If you do the obvious it won't work:
        </p>
        <pre class="tty">## WRONG ##
[[[daytemp_with_avg]]]
    [[[[outTemp]]]]
        aggregate_type = avg
        aggregate_interval = hour
    <span style="text-decoration: line-through; color: red">[[[[outTemp]]]]</span>  # OOPS! The same section name appears more than once!</pre>
        <p>
            The option parser does not allow the same section name (<span class="code">outTemp</span> in this case) to
            appear more than once at a given level in the configuration file, so an error will be declared (technical
            reason: formally, the sections are an unordered dictionary). If you wish for the same observation to appear
            more than once in a plot then there is a trick you must know: use option <span class="code">data_type</span>.
            This will override the default action that the logical line name is used for the database column. So, our
            example would look like this:
        </p>
        <pre class="tty">[[[daytemp_with_avg]]]
    [[[[avgTemp]]]]
        data_type = outTemp
        aggregate_type = avg
        aggregate_interval = hour
        label = Avg. Temp.
    [[[[outTemp]]]]</pre>
        <p>
            Here, the first plot line has been given the name <span class="code">avgTemp</span> to distinguish it from
            the second line <span class="code">outTemp</span>. Any name will do &mdash; it just has to be different. We
            have specified that the first line will use data type <span class="code"> outTemp</span> and that it will
            use averaging over a one hour period. The second also uses <span class="code">outTemp</span>, but will not
            use averaging.
        </p>

        <p>The result is a nice plot of the day's temperature, overlaid with a one hour smoothed average:</p>

        <p>
            <img alt="Daytime temperature with running average" src="images/daytemp_with_avg.png"/>
        </p>

        <p>One more example. This one shows daily high and low temperatures for a year:</p>
        <pre class="tty">[[year_images]]
    [[[yearhilow]]]
        [[[[hi]]]]
            data_type = outTemp
            aggregate_type = max
            label = High
        [[[[low]]]]
            data_type = outTemp
            aggregate_type = min
            label = Low Temperature</pre>
        <p>
            This results in the plot <span class="code">yearhilow.png</span>:
        </p>

        <p>
            <img style="width:300px; height:180px" alt="Daily highs and lows" src="images/yearhilow.png"/>
        </p>

        <h2 id="arbitrary_expressions_in_plot">Including arbitrary expressions</h2>
        <p>
            The option <span class="code">data_type</span> can actually be <em>any arbitrary SQL expression,
            which is valid in the context of the available types in the schema</em>. For
            example, say you wanted to plot the difference between inside and outside temperature for the year. This
            could be done with:
        </p>
        <pre class="tty">[[year_images]]
    [[[yeardiff]]]
        [[[[diff]]]]
            data_type = inTemp-outTemp
            label = Inside - Outside
</pre>

        <p>
            Note that the option <span class="code">data_type</span> is now an expression representing the difference
            between <span class="code">inTemp</span> and <span class="code">outTemp</span>, the inside and outside
            temperature, respectively. This results in a plot <span class="code">yeardiff.png</span>:</p>

        <p>
            <img style="width:300px; height:180px" alt="Inside - outside temperature" src="images/yeardiff.png"/>
        </p>

        <h2>Changing the unit used in a plot</h2>
        <p>
            Normally, the unit used in a plot is set by the unit group of the observation types in the plot.
            For example, consider this plot of today's outside temperature and dewpoint:</p>
        <pre class="tty">
    [[day_images]]
        ...
        [[[daytempdew]]]
            [[[[outTemp]]]]
            [[[[dewpoint]]]]</pre>
        <p>
            Both <span class="code">outTemp</span> and <span class="code">dewpoint</span> belong to unit group <span
            class="code">group_temperature</span>, so this plot will use whatever unit has been specified for that
            group. See the section <a href="#mixed_units"><em>Mixed units</em></a> for details.
        </p>
        <p>
            However, supposed you'd like to offer both Metric and US Customary versions of the same plot? You
            can do this by using option <a href="#imagegenerator-unit"><span class="code">unit</span></a>
            to override the unit used for individual plots:
        </p>

        <pre class="tty">
    [[day_images]]
        ...
        [[[daytempdewUS]]]
            <span class="highlight">unit = degree_F</span>
            [[[[outTemp]]]]
            [[[[dewpoint]]]]

        [[[daytempdewMetric]]]
            <span class="highlight">unit = degree_C</span>
            [[[[outTemp]]]]
            [[[[dewpoint]]]]</pre>

        <p>
            This will produce two plots: file <span class="code">daytempdewUS.png</span> will be in degrees
            Fahrenheit, while file <span class="code">dayTempMetric.png</span> will use degrees Celsius.
        </p>

        <h2 id="line_gaps">Line gaps</h2>

        <p id="line_gap_fraction">
            If there is a time gap in the data, the option <span class="code">line_gap_fraction</span> controls how line
            plots will be drawn. Here's what a plot looks like without and with this option being specified:
        </p>

        <div class="center" style="margin: 0;">
            <div style="float: left">
                <img src="images/day-gap-not-shown.png" alt="Gap not shown"/>

                <div class="image_caption">
                    No <span class="code">line_gap_fraction</span> specified
                </div>
            </div>
            <div>
                <img src="images/day-gap-showing.png" alt="Gap showing"/>

                <div class="image_caption">
                    With <span class="code">line_gap_fraction=0.01</span>. Note how each line has been split into two
                    lines.
                </div>
            </div>
        </div>
        <div style="clear: both"></div>

        <h2>Progressive vector plots</h2>

        <p>
            WeeWX can produce progressive vector plots as well as the more conventional x-y plots. To produce these, use
            plot type <span class="code">vector</span>. You need a vector type to produce this kind of plot. There are
            two: <span class="code">windvec</span>, and <span class="code">windgustvec</span>. While they do not
            actually appear in the database, WeeWX understands that they represent special vector-types. The first,
            <span class="code">windvec</span>, represents the average wind in an archive period, the second, <span
            class="code">windgustvec</span> the max wind in an archive period. Here's how to produce a progressive
            vector for one week that shows the hourly biggest wind gusts, along with hourly averages:
        </p>
        <pre class="tty">[[[weekgustoverlay]]]
    aggregate_interval = hour
    [[[[windvec]]]]
        label = Hourly Wind
        plot_type = vector
        aggregate_type = avg
    [[[[windgustvec]]]]
        label = Gust Wind
        plot_type = vector
        aggregate_type = max</pre>
        <p>
            This will produce an image file with name <span class="code">weekgustoverlay.png</span>. It will consist of
            two progressive vector plots, both using hourly aggregation (3,600 seconds). For the first set of vectors,
            the hourly average will be used. In the second, the max of the gusts will be used:
        </p>

        <p>
            <img alt="hourly average wind vector overlaid with gust vectors" src="images/weekgustoverlay.png"/>
        </p>

        <p>
            By default, the sticks in the progressive wind plots point towards the wind source. That is, the stick for a
            wind from the west will point left. If you have a chronic wind direction (as I do), you may want to rotate
            the default direction so that all the vectors do not line up over the x-axis, overlaying each other. Do this
            by using option <span class="code">vector_rotate</span>. For example, with my chronic westerlies, I set
            <span class="code">vector_rotate</span> to 90.0 for the plot above, so winds out of the west point straight
            up.
        </p>

        <p>
            If you use this kind of plot (the out-of-the-box version of WeeWX includes daily, weekly, monthly, and
            yearly progressive wind plots), a small compass rose will be put in the lower-left corner of the image to
            show the orientation of North.
        </p>

        <h2>Overriding values</h2>

        <p>
            Remember that values at any level can override values specified at a higher level. For example, say you want
            to generate the standard plots, but for a few key observation types such as barometer, you want to also
            generate some oversized plots to give you extra detail, perhaps for an HTML popup. The standard <span
            class="code">weewx.conf</span> file specifies plot size of 300x180 pixels, which will be used for all plots
            unless overridden:
        </p>
        <pre class="tty">[ImageGenerator]
    ...
    image_width = 300
    image_height = 180</pre>
        <p>
            The standard plot of barometric pressure will appear in <span class="code">daybarometer.png</span>:
        </p>
        <pre class="tty">[[[daybarometer]]]
    [[[[barometer]]]] </pre>
        <p>
            We now add our special plot of barometric pressure, but specify a larger image size. This image will be put
            in file <span class="code">daybarometer_big.png</span>.
        </p>
        <pre class="tty">[[[daybarometer_big]]]
    image_width  = 600
    image_height = 360
    [[[[barometer]]]]</pre>


        <!-- -------------------------------------------------------------- -->

        <h1 id="Using_multiple_bindings">Using multiple bindings</h1>

        <p>
            It's easy to use more than one database in your reports. Here's an example. In my office I have two
            consoles: a VantagePro2 connected to a Dell Optiplex, and a WMR100N, connected to a Raspberry Pi. Each is
            running WeeWX. The Dell is using SQLite, the RPi, MySQL.
        </p>

        <p>Suppose I wish to compare the inside temperatures of the two consoles. How would I do that?</p>

        <p>
            It's easier to access MySQL across a network than SQLite, so let's run the reports on the Dell, but access
            the RPi's MySQL database remotely. Here's how the bindings and database sections of <span class="code">weewx.conf</span>
            would look on the Dell:
        </p>
        <pre class="tty">[DataBindings]
    # This section binds a data store to an actual database

    [[wx_binding]]
        # The database to be used - it should match one of the sections in [Databases]
        database = archive_sqlite
        # The name of the table within the database
        table_name = archive
        # The class to manage the database
        manager = weewx.manager.DaySummaryManager
        # The schema defines to structure of the database contents
        schema = schemas.wview_extended.schema

<span class="highlight">    [[wmr100_binding]]
        # Binding for my WMR100 on the RPi
        database = rpi_mysql
        # The name of the table within the database
        table_name = archive
        # The class to manage the database
        manager = weewx.manager.DaySummaryManager
        # The schema defines to structure of the database contents
        schema = schemas.wview_extended.schema</span>

[Databases]
    # This section binds to the actual database to be used

    [[archive_sqlite]]
        database_type = SQLite
        database_name = weewx.sdb

<span class="highlight">    [[rpi_mysql]]
        database_type = MySQL
        database_name = weewx
        host = rpi-bug</span>

[DatabaseTypes]
    #   This section defines defaults for the different types of databases.

    [[SQLite]]
        driver = weedb.sqlite
        # Directory in which the database files are located
        SQLITE_ROOT = %(WEEWX_ROOT)s/archive

    [[MySQL]]
        driver = weedb.mysql
        # The host where the database is located
        host = localhost
        # The user name for logging in to the host
        user = weewx
        # The password for the user name
        password = weewx
    </pre>

        <p>
            The two additions have been <span class="highlight">highlighted</span>. The first, <span class="code">[[wmr100_binding]]</span>,
            adds a new binding called <span class="code">wmr10_binding</span>. It links ("binds") to the new database,
            called <span class="code">rpi_mysql</span>, through the option <span class="code">database</span>. It also
            defines some characteristics of the binding, such as which manager is to be used and what its schema looks
            like.
        </p>

        <p>
            The second addition, <span class="code">[[rpi-mysql]]</span> defines the new database. Option <span
            class="code">database_type</span> is set to <span class="code">MySQL</span>, indicating that it is a MySQL
            database. Defaults for MySQL databases are defined in the section <span class="code">[[MySQL]]</span>. The
            new database accepts all of them, except for <span class="code">host</span>, which as been set to the remote
            host <span class="code">rpi-bug</span>, the name of my Raspberry Pi.
        </p>

        <h2>Explicit binding in tags</h2>

        <p>How do we use this new binding? First, let's do a text comparison, using tags. Here's what our template looks
            like:
        </p>
        <pre class="tty">&lt;table&gt;
  &lt;tr&gt;
    &lt;td class="stats_label"&gt;Inside Temperature, Vantage&lt;/td&gt;
    &lt;td class="stats_data"&gt;$current.inTemp&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="stats_label"&gt;Inside Temperature, WMR100&lt;/td&gt;
    &lt;td class="stats_data"&gt;$latest<span class="highlight">($data_binding='wmr100_binding')</span>.inTemp&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</pre>

        <p>
            The explicit binding to <span class="code">wmr100_binding</span> is highlighted. This tells the reporting
            engine to override the default binding specifed in <span class="code">[StdReport]</span>, generally <span
            class="code">wx_binding</span>, and use <span class="code">wmr100_binding</span> instead.
        </p>

        <p>This results in an HTML output that looks like:</p>

        <div id="stats_group" class="indent">
            <div class="stats example_output">
                <table>
                    <tbody>
                    <tr>
                        <td class="stats_label">Inside Temperature, Vantage</td>
                        <td class="stats_data">68.7&#176;F</td>
                    </tr>
                    <tr>
                        <td class="stats_label">Inside Temperature, WMR100</td>
                        <td class="stats_data">68.9&#176;F</td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <h2>Explicit binding in images</h2>

        <p>
            How would we produce a graph of the two different temperatures? Here's what the relevant section of the
            <span class="code">skin.conf</span> file would look like.
        </p>
        <pre class="tty">[[[daycompare]]]
   [[[[inTemp]]]]
       label = Vantage inTemp
   [[[[WMR100Temp]]]]
       data_type = inTemp
       data_binding = wmr100_binding
       label = WMR100 inTemp</pre>

        <p>
            This will produce an image with name <span class="code">daycompare.png</span>, with two plot lines. The
            first will be of the temperature from the Vantage. It uses the default binding, <span class="code">wx_binding</span>,
            and will be labeled <span class="code">Vantage inTemp</span>. The second explicitly uses the <span
            class="code">wmr100_binding</span>. Because it uses the same variable name (<span class="code">inTemp</span>)
            as the first line, we had to explicitly specify it using option <span class="code">data_type</span>, in
            order to avoid using the same sub-section name twice (see the section <em><a
            href="#including_same_sql_type_2x">Including a type more than once in a plot</a></em> for details). It will
            be labeled <span class="code">WMR100 inTemp</span>. The results look like this:
        </p>
        <img src='images/daycompare.png' alt="Comparing temperatures"/>

        <h2 id="stupid_detail">Stupid detail</h2>

        <p>
            At first, I could not get this example to work. The problem turned out to be that the RPi was processing
            things just a beat behind the Dell, so the temperature for the "current" time wasn't ready when the Dell
            needed it. I kept getting <span class="code">N/A</span>. To avoid this, I introduced the tag <span
            class="code">$latest</span>, which uses the last available timestamp in the binding, which may or may not be
            the same as what <span class="code">$current</span> uses. That's why the example above uses <span
            class="code">$latest</span> instead of <span class="code">$current</span>.
        </p>


        <!-- -------------------------------------------------------------- -->

        <h1 id="localization">Localization</h1>

        <p>
            This section provides suggestions for localization,
            including translation to different languages and
            display of data in formats specific to a locale.
        </p>

        <h2>If the skin has been internationalized</h2>
        <p>
            All of the skins that come with WeeWX have been <em>internationalized</em>, although they may not have
            been <em>localized</em> to your specific language. See the section <a href="#internationalized_skins">
            Internationalized skins</a> for how to tell.
        </p>
        <h3>Internationalized, your language is available</h3>
        <p>
            This is the easy case: the skin has been internationalized, and your locale is available.
            In this case, all you need to do is to select your locale
            in <span class="code">weewx.conf</span>. For example, to select German (code <span class="code">de</span>)
            for the <em>Seasons</em> skin, just add the highlighted line (or change, if it's already there):
        </p>
        <pre class="tty">...
[StdReport]
    ...
    [[SeasonsReport]]
        # The SeasonsReport uses the 'Seasons' skin, which contains the
        # images, templates and plots for the report.
        skin = Seasons
        enable = true
        <span class="highlight">lang = de</span>
        ...</pre>

        <h3 id="internationalized-missing-language">Internationalized, but your language is missing</h3>

        <p>
            If the <span class="code">lang</span> subdirectory is present in the skin directory, then the skin has been
            internationalized. However, if your language code is not included in the subdirectory, then you will have to
            <em>localize</em> it to your language. To do so, copy the file <span class="code">en.conf</span> and name it
            according to the language code of your language. Then translate all the strings on the right side of the
            equal signs to your language. For example, say you want to localize the skin in the French language. Then
            copy <span class="code">en.conf</span> to <span class="code">fr.conf</span>
        </p>
        <pre class="cmd tty">cp en.conf fr.conf</pre>
        <p>
            Then change things that look like this:
        </p>
        <pre class="tty">
...
[Texts]
    "Language" = "English"

    "7-day" = "7-day"
    "24h" = "24h"
    "About this weather station" = "About this weather station"
    ...
</pre>
        <p>to something that looks like this:</p>
        <pre class="tty">
...
[Texts]
    Language = French

    "7-day" = "7-jours"
    "24h" = "24h"
    "About this weather station" = "A propos de cette station"
    ...
</pre>
        <p>
            And so on. When you're done, the skin author may be interested in your localization file to ship it together
            with the skin for the use of other users. If the skin is one that came with WeeWX, contact the WeeWX team
            via a post to the <a href="https://groups.google.com/forum/#!forum/weewx-user">weewx-user group</a> and,
            with your permission, we may include your localization file in a future WeeWX release.
        </p>
        <p>
            Finally, set the option <span class="code">lang</span> in <span class="code">weewx.conf</span> to your
            language code (<span class="code">fr</span> in this example) as described in the
            <a href="usersguide.htm#lang-code">User's Guide</a>.
        </p>

        <h2>How to internationalize a skin</h2>

        <p>
            What happens when you come across a skin that you like, but it has not been internationalized? This section
            explains how to convert the report to local formats and language.
        </p>

        <p>
            Internationalization of WeeWX templates uses a pattern very similar to the well-known
            GNU "<a href="https://www.gnu.org/software/gettext/"><span class="code">gettext</span></a>" approach. The
            only difference is that we have leveraged the <span class="code">ConfigObj</span> facility used throughout
            WeeWX.
        </p>

        <h3>Create the localization file</h3>

        <p>
            Create a subdirectory called <span class="code">lang</span> in the skin directory.
            Then create a file named by the language code with the suffix <span class="code">.conf</span>. For example,
            if you want to translate to Spanish, name the file <span class="code">es.conf</span>. Include the following
            in the file:
        </p>

        <pre class="tty">
[Units]

    [[Labels]]

        # These are singular, plural
        meter             = " meter",  " meters"
        day               = " day",    " days"
        hour              = " hour",   " hours"
        minute            = " minute", " minutes"
        second            = " second", " seconds"

    [[Ordinates]]

        # Ordinal directions. The last one should be for no wind direction
        directions = N, NNE, NE, ENE, E, ESE, SE, SSE, S, SSW, SW, WSW, W, WNW, NW, NNW, N/A

[Labels]

    # Set to hemisphere abbreviations suitable for your location:
    hemispheres = N, S, E, W

    # Generic labels, keyed by an observation type.
    [[Generic]]
        altimeter              = Altimeter                # QNH
        altimeterRate          = Altimeter Change Rate
        appTemp                = Apparent Temperature
        appTemp1               = Apparent Temperature
        barometer              = Barometer                # QFF
        barometerRate          = Barometer Change Rate
        cloudbase              = Cloud Base
        dateTime               = Time
        dewpoint               = Dew Point
        ET                     = ET
        extraTemp1             = Temperature1
        extraTemp2             = Temperature2
        extraTemp3             = Temperature3
        heatindex              = Heat Index
        inDewpoint             = Inside Dew Point
        inHumidity             = Inside Humidity
        inTemp                 = Inside Temperature
        interval               = Interval
        lightning_distance     = Lightning Distance
        lightning_strike_count = Lightning Strikes
        outHumidity            = Outside Humidity
        outTemp                = Outside Temperature
        pressure               = Pressure                 # QFE
        pressureRate           = Pressure Change Rate
        radiation              = Radiation
        rain                   = Rain
        rainRate               = Rain Rate
        THSW                   = THSW Index
        UV                     = UV Index
        wind                   = Wind
        windchill              = Wind Chill
        windDir                = Wind Direction
        windGust               = Gust Speed
        windGustDir            = Gust Direction
        windgustvec            = Gust Vector
        windrun                = Wind Run
        windSpeed              = Wind Speed
        windvec                = Wind Vector


[Almanac]

    # The labels to be used for the phases of the moon:
    moon_phases = New, Waxing crescent, First quarter, Waxing gibbous, Full, Waning gibbous, Last quarter, Waning crescent

[Texts]

    Language              = Espaol # Replace with the language you are targeting
        </pre>

        <p>
            Go through the file, translating all phrases on the right-hand side of the equal signs to your target
            language (Spanish in this example).
        </p>

        <h3>Internationalize the template</h3>
        <p>
            You will need to internationalize every HTML template (these typically have a file suffix of
            <span class="code">.html.tmpl</span>). This is most easily done
            by opening the template and the language file in different editor windows.
            It is much easier if you can change both files simultaneously.
        </p>

        <h4>Change the <span class="code">html lang</span> attribute</h4>
        <p>
            At the top of the template, change the HTML "lang" attribute to a configurable value.
        </p>
        <pre class="tty">
&lt;!DOCTYPE html&gt;
&lt;html lang="<span class="highlight">$lang</span>"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    ...
</pre>
        <p>
            The value <span class="code">$lang</span> will get replaced by the actual language to be used.
        </p>

        <p>
            <a href="https://www.w3schools.com/tags/ref_language_codes.asp">language codes</a><br/> <a
            href="https://www.w3schools.com/tags/ref_country_codes.asp">country codes</a><br/>
        </p>

        <h4>Change the body text</h4>
        <p>
            The next step is to go through the templates and change all natural language phrases into lookups using
            <span class="code">$gettext</span>. For example, suppose your skin has a section that looks like this:
        </p>

       <pre class="tty">
&lt;div&gt;
    Current Conditions
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;Outside Temperature&lt;/td&gt;
            &lt;td&gt;$current.outTemp&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/div&gt;
</pre>

        <p>
            There are two natural language phrases here: <em>Current Conditions</em> and <em>Outside Temperature</em>.
            They would be changed to:
        </p>
       <pre class="tty">
&lt;div&gt;
    <span class="highlight">$gettext("Current Conditions")</span>
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;<span class="highlight">$obs.label.outTemp</span>&lt;/td&gt;
            &lt;td&gt;$current.outTemp&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/div&gt;
</pre>
        <p>
            We have done two replacements here. For the phrase <em>Current Conditions</em>, we substituted
            <span class="code">$gettext("Current Conditions")</span>. This will cause the Cheetah Generator to look up
            the localized version of "Current Conditions" in the localization file and substitute it. We could have
            done something similar for <em>Outside Temperature</em>, but in this case, we chose to use the localized
            name for type <span class="code">outTemp</span>, which you should have provided in your localization file,
            under section <span class="code">[Labels] / [[Generic]]</span>.
        </p>
        <p>
            In the localization file, include the translation for <em>Current Conditions</em> under the <span class="code">[Texts]</span> section:
        </p>
        <pre class="tty">...
[Texts]

    "Language"           = "Espaol"
    <span class="highlight">"Current Conditions" = "Condiciones Actuales"</span>
    ...</pre>
        <p>
            Repeat this process for all the strings that you find. Make sure not to replace HTML tags and HTML
            options.
        </p>

        <h3>Think about time</h3>

        <p>
            Whenever a time is used in a template, it will need a format. WeeWX comes with the following set of
            defaults, defined in <span class="code">defaults.py</span>:
        </p>
        <pre class="tty">
[Units]
    ...
    [[TimeFormats]]
        day        = <span class="highlight">%X</span>
        week       = <span class="highlight">%X (%A)</span>
        month      = <span class="highlight">%x %X</span>
        year       = <span class="highlight">%x %X</span>
        rainyear   = <span class="highlight">%x %X</span>
        current    = <span class="highlight">%x %X</span>
        ephem_day  = <span class="highlight">%X</span>
        ephem_year = <span class="highlight">%x %X</span>
</pre>

        <p>
            These defaults will give something readable in every locale, but they may not be very pretty. Therefore,
            you may want to change them to something more suitable for the locale you are targeting, using the Python
            <a href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior"><span class="code">strftime()</span>
                specific directives</a>.
        </p>
        <p>
            Example: the default time formatting for "Current" conditions is <span class="code">%x %x</span>, which will
            show today's date as 14/05/21 10:00:00 in the Spanish locale. Suppose you would rather see
            14-mayo-2021 10:00. You would add the following to your
            Spanish localization file <span class="code">es.conf</span>:
        </p>
        <pre class="tty">
...

[Units]
    [[TimeFormats]]
        current = <span class="highlight">%d-%B-%Y %H:%M</span>

...     </pre>

        <h3 id="environment_variable_LANG">
            Set the environment variable <span class="code">LANG</span>
        </h3>

        <p>
            Finally, you will need to set the environment variable <span class="code">LANG</span> to reflect your
            locale. For example, assuming you set
        </p>
        <pre class="tty">$ export LANG=es_ES.UTF-8</pre>
        <p>
            before running WeeWX, then the local Spanish names for days of the week and months of the year will be used.
            The decimal point for numbers will also be modified appropriately.
        </p>

        <!-- -------------------------------------------------------------- -->

        <h1 id="service_engine">Customizing the WeeWX service engine </h1>

        <p>This is an advanced topic intended for those who wish to try their hand at extending the internal engine in
            WeeWX. Before attempting these examples, you should be reasonably proficient with Python.
        </p>

        <p class="warning">Please note that the API to the service engine may change in future versions!</p>

        <p>
            At a high level, WeeWX consists of an <em>engine</em> that is responsible for managing a set of
            <em>services</em>. A service consists of a Python class which binds its member functions to various <em>events</em>.
            The engine arranges to have the bound member function called when a specific event happens, such as a new
            LOOP packet arriving.
        </p>

        <p>
            The services are specified in lists in the <a href="usersguide.htm#engine_services"><span class="code">[Engine][[Services]]</span></a>
            stanza of the configuration file. The <span class="code">[[Services]]</span> section lists all the services
            to be run, broken up into different <em>service lists</em>.
        </p>

        <p>
            These lists are designed to orchestrate the data as it flows through the WeeWX engine. For example, you want
            to make sure data has been processed by, for example, running it through the quality control service, <span
            class="code">StdQC</span>, before putting them in the database. Similarly, the reporting system must come
            <em>after</em> the archiving service. These groups insure that things happen in the proper sequence.
        </p>
        <p>
            See the table <a href="#default_services">Default services</a> for a list of the services that are normally
            run.
        </p>

        <h2 id="Customizing_a_service">Modifying an existing service</h2>

        <p>
            The service <span class="code">weewx.engine.StdPrint</span> prints out new LOOP and archive packets to the
            console when they arrive. By default, it prints out the entire record, which generally includes a lot of
            possibly distracting information and can be rather messy. Suppose you do not like this, and want it to print
            out only the time, barometer reading, and the outside temperature whenever a new LOOP packet arrives. This
            could be done by subclassing the default print service <span class="code">StdPrint</span> and overriding
            member function <span class="code">new_loop_packet()</span>.
        </p>

        <p>
            Create the file <span class="code">user/myprint.py</span>:
        </p>
        <pre class="tty">from weewx.engine import StdPrint
from weeutil.weeutil import timestamp_to_string

class MyPrint(StdPrint):

    # Override the default new_loop_packet member function:
    def new_loop_packet(self, event):
        packet = event.packet
        print("LOOP: ", timestamp_to_string(packet['dateTime']),
            "BAR=",  packet.get('barometer', 'N/A'),
            "TEMP=", packet.get('outTemp', 'N/A'))</pre>
        <p>
            This service substitutes a new implementation for the member function <span
            class="code">new_loop_packet</span>. This implementation prints out the time, then the barometer reading (or
            <span class="code">N/A</span> if it is not available) and the outside temperature (or <span
            class="code">N/A</span>).
        </p>

        <p>
            You then need to specify that your print service class should be loaded instead of the default <span
            class="code">StdPrint</span> service. This is done by substituting your service name for <span class="code">StdPrint</span>
            in <span class="code">service_list</span>, located in <span class="code">[Engine][[Services]]</span>:
        </p>
        <pre class="tty">[Engine]
    [[Services]]
        ...
        report_services = <span class="highlight">user.myprint.MyPrint</span>, weewx.engine.StdReport</pre>
        <p>
            Note that the <span class="code">report_services</span> must be all on one line. Unfortunately, the parser
            <span class="code">ConfigObj</span> does not allow options to be continued on to following lines.
        </p>


        <h2 id="Adding_a_service">Creating a new service</h2>

        <p>
            Suppose there is no service that can be easily customized for your needs. In this case, a new one can easily
            be created by subclassing off the abstract base class <span class="code">StdService</span>, and then adding
            the functionality you need. Here is an example that implements an alarm, which sends off an email when an
            arbitrary expression evaluates <span class="code">True</span>.
        </p>

        <p>
            This example is included in the standard distribution as <span class="code">examples/alarm.py:</span>
        </p>

        <pre class="tty">
import smtplib
import socket
import syslog
import threading
import time
from email.mime.text import MIMEText

import weewx
from weeutil.weeutil import timestamp_to_string, option_as_list
from weewx.engine import StdService


# Inherit from the base class StdService:
class MyAlarm(StdService):
    """Service that sends email if an arbitrary expression evaluates true"""

    def __init__(self, engine, config_dict):
        # Pass the initialization information on to my superclass:
        super(MyAlarm, self).__init__(engine, config_dict)

        # This will hold the time when the last alarm message went out:
        self.last_msg_ts = 0

        try:
            # Dig the needed options out of the configuration dictionary.
            # If a critical option is missing, an exception will be raised and
            # the alarm will not be set.
            self.expression    = config_dict['Alarm']['expression']
            self.time_wait     = int(config_dict['Alarm'].get('time_wait', 3600))
            self.timeout       = int(config_dict['Alarm'].get('timeout', 10))
            self.smtp_host     = config_dict['Alarm']['smtp_host']
            self.smtp_user     = config_dict['Alarm'].get('smtp_user')
            self.smtp_password = config_dict['Alarm'].get('smtp_password')
            self.SUBJECT       = config_dict['Alarm'].get('subject', "Alarm message from weewx")
            self.FROM          = config_dict['Alarm'].get('from', 'alarm@example.com')
            self.TO            = option_as_list(config_dict['Alarm']['mailto'])
            syslog.syslog(syslog.LOG_INFO, "alarm: Alarm set for expression: '%s'" % self.expression)

            # If we got this far, it's ok to start intercepting events:
            self.bind(weewx.NEW_ARCHIVE_RECORD, self.new_archive_record)    # NOTE 1
        except KeyError as e:
            syslog.syslog(syslog.LOG_INFO, "alarm: No alarm set.  Missing parameter: %s" % e)

    def new_archive_record(self, event):
        """Gets called on a new archive record event."""

        # To avoid a flood of nearly identical emails, this will do
        # the check only if we have never sent an email, or if we haven't
        # sent one in the last self.time_wait seconds:
        if not self.last_msg_ts or abs(time.time() - self.last_msg_ts) >= self.time_wait:
            # Get the new archive record:
            record = event.record

            # Be prepared to catch an exception in the case that the expression contains
            # a variable that is not in the record:
            try:                                                              # NOTE 2
                # Evaluate the expression in the context of the event archive record.
                # Sound the alarm if it evaluates true:
                if eval(self.expression, None, record):                       # NOTE 3
                    # Sound the alarm!
                    # Launch in a separate thread so it doesn't block the main LOOP thread:
                    t = threading.Thread(target=MyAlarm.sound_the_alarm, args=(self, record))
                    t.start()
                    # Record when the message went out:
                    self.last_msg_ts = time.time()
            except NameError as e:
                # The record was missing a named variable. Log it.
                syslog.syslog(syslog.LOG_DEBUG, "alarm: %s" % e)

    def sound_the_alarm(self, rec):
        """Sound the alarm in a 'try' block"""

        # Wrap the attempt in a 'try' block so we can log a failure.
        try:
            self.do_alarm(rec)
        except socket.gaierror:
            # A gaierror exception is usually caused by an unknown host
            syslog.syslog(syslog.LOG_CRIT, "alarm: unknown host %s" % self.smtp_host)
            # Reraise the exception. This will cause the thread to exit.
            raise
        except Exception as e:
            syslog.syslog(syslog.LOG_CRIT, "alarm: unable to sound alarm. Reason: %s" % e)
            # Reraise the exception. This will cause the thread to exit.
            raise

    def do_alarm(self, rec):
        """Send an email out"""

        # Get the time and convert to a string:
        t_str = timestamp_to_string(rec['dateTime'])

        # Log the alarm
        syslog.syslog(syslog.LOG_INFO, 'alarm: Alarm expression "%s" evaluated True at %s' % (self.expression, t_str))

        # Form the message text:
        msg_text = 'Alarm expression "%s" evaluated True at %s\nRecord:\n%s' % (self.expression, t_str, str(rec))
        # Convert to MIME:
        msg = MIMEText(msg_text)

        # Fill in MIME headers:
        msg['Subject'] = self.SUBJECT
        msg['From']    = self.FROM
        msg['To']      = ','.join(self.TO)

        try:
            # First try end-to-end encryption
            s = smtplib.SMTP_SSL(self.smtp_host, timeout=self.timeout)
            syslog.syslog(syslog.LOG_DEBUG, "alarm: using SMTP_SSL")
        except (AttributeError, socket.timeout, socket.error):
            syslog.syslog(syslog.LOG_DEBUG, "alarm: unable to use SMTP_SSL connection.")
            # If that doesn't work, try creating an insecure host, then upgrading
            s = smtplib.SMTP(self.smtp_host, timeout=self.timeout)
            try:
                # Be prepared to catch an exception if the server
                # does not support encrypted transport.
                s.ehlo()
                s.starttls()
                s.ehlo()
                syslog.syslog(syslog.LOG_DEBUG,
                              "alarm: using SMTP encrypted transport")
            except smtplib.SMTPException:
                syslog.syslog(syslog.LOG_DEBUG,
                              "alarm: using SMTP unencrypted transport")

        try:
            # If a username has been given, assume that login is required for this host:
            if self.smtp_user:
                s.login(self.smtp_user, self.smtp_password)
                syslog.syslog(syslog.LOG_DEBUG, "alarm: logged in with user name %s" % self.smtp_user)

            # Send the email:
            s.sendmail(msg['From'], self.TO,  msg.as_string())
            # Log out of the server:
            s.quit()
        except Exception as e:
            syslog.syslog(syslog.LOG_ERR, "alarm: SMTP mailer refused message with error %s" % e)
            raise

        # Log sending the email:
        syslog.syslog(syslog.LOG_INFO, "alarm: email sent to: %s" % self.TO)
</pre>

        <p>
            This service expects all the information it needs to be in the configuration file <span class="code">weewx.conf</span>
            in a new section called <span class="code">[Alarm]</span>. So, add the following lines to your configuration
            file:
        </p>
        <pre class="tty">[Alarm]
    expression = "outTemp &lt; 40.0"
    time_wait = 3600
    smtp_host = smtp.example.com
    smtp_user = myusername
    smtp_password = mypassword
    mailto = auser@example.com, anotheruser@example.com
    from   = me@example.com
    subject = "Alarm message from WeeWX!"</pre>
        <p>
            There are three important points to be noted in this example, each marked with a <span
            class="code">NOTE</span> flag in the code.
        </p>
        <ol>
            <li>Here is where the binding happens between an event, <span class="code">weewx.NEW_ARCHIVE_RECORD</span>
                in this example, and a member function, <span class="code">self.new_archive_record</span>. When the
                event <span class='code'>NEW_ARCHIVE_RECORD</span> occurs, the function <span class="code">self.new_archive_record</span>
                will be called. There are many other events that can be intercepted. Look in the file <span
                    class="code">weewx/__init__.py</span>.
            </li>
            <li>Some hardware does not emit all possible observation types in every record. So, it's possible that a
                record may be missing some types that are used in the expression. This try block will catch the <span
                    class="code">NameError</span> exception that would be raised should this occur.
            </li>
            <li>This is where the test is done for whether or not to sound the alarm. The <span
                class="code">[Alarm]</span> configuration options specify that the alarm be sounded when <span
                class="code">outTemp &lt; 40.0</span> evaluates <span class="code">True</span>, that is when the outside
                temperature is below 40.0 degrees. Any valid Python expression can be used, although the only variables
                available are those in the current archive record.
            </li>
        </ol>
        <p>Another example expression could be:</p>
        <pre class="tty">expression = "outTemp &lt; 32.0 and windSpeed &gt; 10.0"</pre>
        <p>In this case, the alarm is sounded if the outside temperature drops below freezing and the wind speed is
            greater than 10.0.
        </p>

        <p>
            Note that units must be the same as whatever is being used in your database. That is, the same as what you
            specified in option <a href="usersguide.htm#option_target_unit"><span class="code">target_unit</span></a>.
        </p>

        <p>
            Option <span class="code">time_wait</span> is used to avoid a flood of nearly identical emails. The new
            service will wait this long before sending another email out.
        </p>

        <p>
            Email will be sent through the SMTP host specified by option <span class="code">smtp_host</span>. The
            recipient(s) are specified by the comma separated option <span class="code">mailto</span>.
        </p>

        <p>
            Many SMTP hosts require user login. If this is the case, the user and password are specified with options
            <span class="code">smtp_user</span> and <span class="code">smtp_password</span>, respectively.
        </p>

        <p>
            The last two options, <span class="code">from</span> and <span class="code">subject</span> are optional. If
            not supplied, WeeWX will supply something sensible. Note, however, that some mailers require a valid "from"
            email address and the one WeeWX supplies may not satisfy its requirements.
        </p>

        <p>
            To make this all work, you must first copy the <span class="code">alarm.py</span> file to the <span
            class="code">user</span> directory. Then tell the engine to load this new service by adding the service name
            to the list <span class="code">report_services</span>, located in <span
            class="code">[Engine][[Services]]</span>:
        </p>
        <pre class="tty">[Engine]
   [[Services]]
        report_services = weewx.engine.StdPrint, weewx.engine.StdReport<span
                class="highlight">, user.alarm.MyAlarm</span></pre>
        <p>
            Again, note that the option <span class="code">report_services</span> must be all on one line &mdash; the
            parser <span class="code">ConfigObj</span> does not allow options to be continued on to following lines.
        </p>

        <p>
            In addition to this example, the distribution also includes a low-battery alarm (<span class="code">lowBattery.py</span>),
            which is similar, except that it intercepts LOOP events (instead of archiving events).
        </p>


        <h2 id="Adding_2nd_source">Adding a second data source</h2>

        <p>A very common problem is wanting to augment the data from your weather station with data from some other
            device. Generally, you have two approaches for how to handle this:
        </p>
        <ul>
            <li>Run two instances of WeeWX, each using its own database and <span class='code'>weewx.conf</span>
                configuration file. The results are then combined in a final report, using WeeWX's ability <a
                    href="#Using_multiple_bindings">to use more than one database</a>. See the Wiki entry <a
                    href="https://github.com/weewx/weewx/wiki/weewx-multi"> <em>How to run multiple instances of
                    WeeWX</em></a> for details on how to do this.
            </li>
            <li>Run one instance, but use a custom WeeWX service to augment the records coming from your weather station
                with data from the other device.
            </li>
        </ul>

        <p>This section covers the latter approach.</p>

        <p>Suppose you have installed an electric meter at your house and you wish to correlate electrical usage with
            the weather. The meter has some sort of connection to your computer, allowing you to download the total
            power consumed. At the end of every archive interval you want to calculate the amount of power consumed
            during the interval, then add the results to the record coming off your weather station. How would you do
            this?
        </p>

        <p>Here is the outline of a service that retrieves the electrical consumption data and adds it to the archive
            record. It assumes that you already have a function <span class='code'>download_total_power()</span> that,
            somehow, downloads the amount of power consumed since time zero.
        </p>

        <p>
            File <span class="code">user/electricity.py</span>
        </p>
        <pre class="tty">import weewx
from weewx.engine import StdService

class AddElectricity(StdService):

    def __init__(self, engine, config_dict):

      # Initialize my superclass first:
      super(AddElectricity, self).__init__(engine, config_dict)

      # Bind to any new archive record events:
      self.bind(weewx.NEW_ARCHIVE_RECORD, self.new_archive_record)

      self.last_total = None

    def new_archive_record(self, event):

        total_power = download_total_power()

        if self.last_total:
            net_consumed = total_power - self.last_total
            event.record['electricity'] = net_consumed

        self.last_total = total_power</pre>
        <p>
            This adds a new key <span class="code">electricity</span> to the record dictionary and sets it equal to the
            difference between the amount of power currently consumed and the amount consumed at the last archive
            record. Hence, it will be the amount of power consumed over the archive interval. The unit should be
            Watt-hours.
        </p>

        <p>
            As an aside, it is important that the function <span class='code'>download_total_power()</span> does not
            delay very long because it will sit right in the main loop of the WeeWX engine. If it's going to cause a
            delay of more than a couple seconds you might want to put it in a separate thread and feed the results to
            <span class="code">AddElectricity</span> through a queue.
        </p>

        <p>
            To make sure your service gets run, you need to add it to one of the service lists in <span class="code">weewx.conf</span>,
            section <span class="code">[Engine]</span>, subsection <span class="code">[[Services]]</span>.
        </p>

        <p>
            In our case, the obvious place for our new service is in <span class="code">data_services</span>. When
            you're done, your section <span class="code">[Engine]</span> will look something like this:
        </p>
        <pre class="tty">
#   This section configures the internal WeeWX engine.

[Engine]

    [[Services]]
        # This section specifies the services that should be run. They are
        # grouped by type, and the order of services within each group
        # determines the order in which the services will be run.
        xtype_services = weewx.wxxtypes.StdWXXTypes, weewx.wxxtypes.StdPressureCooker, weewx.wxxtypes.StdRainRater, weewx.wxxtypes.StdDelta
        prep_services = weewx.engine.StdTimeSynch
        data_services = <span class="highlight">user.electricity.AddElectricity</span>
        process_services = weewx.engine.StdConvert, weewx.engine.StdCalibrate, weewx.engine.StdQC, weewx.wxservices.StdWXCalculate
        archive_services = weewx.engine.StdArchive
        restful_services = weewx.restx.StdStationRegistry, weewx.restx.StdWunderground, weewx.restx.StdPWSweather, weewx.restx.StdCWOP, weewx.restx.StdWOW, weewx.restx.StdAWEKAS
        report_services = weewx.engine.StdPrint, weewx.engine.StdReport
</pre>

        <!-- -------------------------------------------------------------- -->

        <h1 id="archive_database">Customizing the database</h1>

        <p>
            For most users the database defaults will work just fine. However, there may be occasions when you may want
            to add a new observation type to your database, or change its unit system. This section shows you how to do
            this.
        </p>
        <p>
            Every relational database depends on a <em>schema</em> to specify which types to include in the database.
            When a WeeWX database is first created, it uses a Python version of the schema to initialize the database.
            However, once the database has been created, the schema is read directly from the database and the Python
            version is not used again &mdash; any changes to it will have no effect. This means that the strategy for
            modifying the schema depends on whether the database already exists.
        </p>

        <h2>Specifying a schema for a new database</h2>
        <p>
            If the database does not exist yet, then you will want to pick an appropriate starting
            schema. If it's not exactly what you want, you can modify it to fit your needs.
        </p>

        <h3>Picking a starting schema</h3>
        <p>
            WeeWX gives you a choice of three different schemas to choose from when creating a new database:
        </p>
        <table class="indent">
            <tbody>
            <tr class="first_row">
                <td>Name</td>
                <td>Number of observation types</td>
                <td>Comment</td>
            </tr>
            <tr>
                <td class="code">schemas.wview.schema</td>
                <td>49</td>
                <td>The original schema that came with wview.</td>
            </tr>
            <tr>
                <td class="code">schemas.wview_extended.schema</td>
                <td>111</td>
                <td>A version of the wview schema, which has been extended with many new types. This is the default
                version.</td>
            </tr>
            <tr>
                <td class="code">schemas.wview_small.schema</td>
                <td>20</td>
                <td>A minimalist version of the wview schema. </td>
            </tr>
            </tbody>
        </table>

        <p>
            For most users, the default database schema, <span class="code">schemas.wview_extended.schema</span>,
            will work just fine.
        </p>

        <p>
            To specify which schema to use when creating a database, modify option <span class="code">schema</span> in
            section <span class="code">[DataBindings]</span> in <span class="code">weewx.conf</span>. For example,
            suppose you wanted to use the classic (and smaller) schema <span class="code">schemas.wview.schema</span>
            instead of the default <span class="code">schemas.wview_extended.schema</span>. Then the section <span
            class="code">[DataBindings]</span> would look like:
        </p>

        <pre class="tty">[DataBindings]
    [[wx_binding]]
        database = archive_sqlite
        table_name = archive
        manager = weewx.manager.DaySummaryManager
        <span class="highlight">schema = schemas.wview.schema</span></pre>

        <p>
            Now, when you start WeeWX, it will use this new choice instead of the default.
        </p>
        <p class="note">
            NOTE: This only works when the database is <em>first created</em>. Thereafter, WeeWX reads the schema
            directly from the database. Changing this option will have no effect!
        </p>

        <h3 id="modify_starting_schema">Modifying a starting schema</h3>

        <p>
            If none of the three starting schemas that come with WeeWX suits your purposes, you can easily create your
            own. Just pick one of the three schemas as a starting point, then modify it. Put the results in the <span
            class="code">user</span> subdirectory, where it will be safe from upgrades. For example, suppose you like
            the <span class="code">schemas.wview_small</span> schema, but you need to store the type <span
            class="code">electricity</span> from the example <a href="#Adding_2nd_source"><em>Adding a second data
            source</em></a> above. The type <span class="code">electricity</span> does not appear in the schema, so
            you'll have to add it before starting up WeeWX. We will call the resulting new schema
            <span class="code">user.myschema.schema</span>.
        </p>
        <p>
            If you did a Debian install, here's how you would do this:
        </p>
        <pre class="tty"># Copy the wview_small schema over to the user subdirectory and rename it myschema:
<span class="cmd">sudo cp /usr/share/weewx/schemas/wview_small.py /usr/share/weewx/user/myschema.py</span>

# Edit it using your favorite text editor
<span class="cmd">sudo nano /usr/share/weewx/user/myschema.py</span>
</pre>

        <p>If you did a <span class="code">setup.py</span> install, it would look like this:</p>
        <pre class="tty"># Copy the wview_small schema over to the user subdirectory and rename it myschema:
<span class="cmd">cp /home/weewx/bin/schemas/wview_small.py /home/weewx/bin/user/myschema.py</span>

# Edit it using your favorite text editor
<span class="cmd">nano /home/weewx/bin/user/myschema.py</span>
</pre>

        <p>In <span class="code">myschema.py</span> change this:</p>
        <pre class="tty">         ...
         ('windchill',            'REAL'),
         ('windDir',              'REAL'),
         ('windGust',             'REAL'),
         ('windGustDir',          'REAL'),
         ('windSpeed',            'REAL'),
         ]
</pre>
        <p>to this</p>
        <pre class="tty">         ...
         ('windchill',            'REAL'),
         ('windDir',              'REAL'),
         ('windGust',             'REAL'),
         ('windGustDir',          'REAL'),
         ('windSpeed',            'REAL'),
         <span class="highlight">('electricity',          'REAL'),</span>
         ]
</pre>
        <p>
            The only change was the addition (<span class="highlight">highlighted</span>) of <span
            class="code">electricity</span> to the list of observation names.
        </p>

        <p>
            Now change option <span class="code">schema</span> under <span class="code">[DataBindings]</span> in
            <span class="code">weewx.conf</span> to use your new schema:
        </p>
        <pre class="tty">[DataBindings]
    [[wx_binding]]
        database = archive_sqlite
        table_name = archive
        manager = weewx.manager.DaySummaryManager
        <span class="highlight">schema = user.myschema.schema</span></pre>

        <p>
            Start WeeWX. When the new database is created, it will use your modified schema instead of the default.
        </p>
        <p class="note">
            NOTE: This will only work when the database is first created! Thereafter, WeeWX reads the schema directly
            from the database and your changes will have no effect!
        </p>


        <h2>Modifying an existing database</h2>
        <p>
            The previous section covers the case where you do not have an existing database, so you modify a starting
            schema, then use it to initialize the database. But, what if you already have a database, and you want to
            modify it, perhaps by adding a column or two? You cannot create a new starting schema, because it is only
            used when the database is first created. Here is where the tool <a
            href="utilities.htm#wee_database_utility"><span class="code">wee_database</span></a> can be useful. Be sure
            to stop WeeWX before attempting to use it.
        </p>
        <p>
            There are two ways to do this. Both are covered below.
        </p>
        <ol>
            <li>Modify the database <em>in situ</em> by using the tool <span class="code">wee_database</span>. This
                choice works best for small changes.
            </li>
            <li>Transfer the old database to a new one while modifying it along the way, again by using the tool <span
                class="code">wee_database</span>. This choice is best for large modifications.
            </li>
        </ol>

        <p class="warning">
            NOTE: Before using the tool <span class="code">wee_database</span>, MAKE A BACKUP FIRST!
        </p>

        <h3 id="add_archive_type">Modify the database <em>in situ</em></h3>
        <p>
            If you want to make some minor modifications to an existing database, perhaps adding or removing a column,
            then this can easily be done using the tool <span class="code">wee_database</span> with an appropriate
            option. We will cover the cases of adding, removing, and renaming a type. See the documentation for <a
            href="utilities.htm#wee_database_utility"><span class="code">wee_database</span></a> for more details.
        </p>

        <h4>Adding a type</h4>

        <p>
            Suppose you have an existing database and you want to add a type, such as the type <span class="code">electricity</span>
            from the example above <a href="#Adding_2nd_source"><em>Adding a second data source</em></a>. This can be
            done in one easy step using the tool <span class="code">wee_database</span> with the option <span
            class="code">--add-column</span>:
        </p>
        <pre class="tty cmd">wee_database --add-column=electricity</pre>
        <p>
            The tool not only adds <span class="code">electricity</span> to the main archive table, but also to the
            daily summaries.
        </p>

        <h4 id="remove_archive_type">Removing a type </h4>
        <p>
            In a similar manner, the tool can remove any unneeded types from an existing database. For example, suppose
            you are using the <span class="code">schemas.wview</span> schema, but you're pretty sure you're not going to
            need to store soil moisture. You can drop the unnecessary types this way:
        </p>
        <pre class="tty cmd">wee_database --drop-columns=soilMoist1,soilMoist2,soilMoist3,soilMoist4</pre>
        <p>
            Unlike the option <span class="code">--add-column</span>, the option <span
            class="code">--drop-columns</span> can take more than one type. This is done in the interest of efficiency:
            adding new columns is easy and fast with the SQLite database, but dropping columns requires copying the
            whole database. By specifying more than one type, you can amortize the cost over a single invocation of the
            utility.
        </p>
        <p class="warning">
            NOTE: Dropping types from a database means <em>you will lose any data associated with them!</em> The data
            cannot be recovered.
        </p>

        <h4>Renaming a type</h4>
        <p>
            Suppose you just want to rename a type? This can be done using the option <span class="code">--to-name</span>.
            Here's an example where you rename <span class="code">soilMoist1</span> to <span class="code">soilMoistGarden</span>:
        </p>
        <pre class="tty cmd">wee_database --rename-column=soilMoist1 --to-name=soilMoistGarden</pre>

        <p>
            Note how the option <span class="code">--rename-column</span> also requires option
            <span class="code">--to-name</span>, which specifies the target name.
        </p>

        <h3 id="transfer_database_using_new_schema">Transfer database using new schema</h3>
        <p>
            If you are making major changes to your database, you may find it easier to create a brand new database
            using the schema you want, then transfer all data from the old database into the new one. This approach
            is more work, and takes more processing time than the <em>in situ</em> strategies outlines above,
            but has the advantage that it leaves behind a record of exactly the schema you are using.
        </p>

        <p>Here is the general strategy of how to do this.</p>

        <ol>
            <li>Create a new schema that includes exactly the types that you want.</li>
            <li>Specify this schema as the starting schema for the database.</li>
            <li>Make sure you have the necessary permissions to create the new database.</li>
            <li>
                Use the utility <a href="utilities.htm#wee_database_utility"><span class="code">wee_database</span></a>
                to create the new database and populate it with data from the old database.
            </li>
            <li>Shuffle databases around so WeeWX will use the new database.</li>
        </ol>
        <p>Here are the details:</p>

        <ol>
            <li>
                <p><strong>Create a new schema.</strong> First step is to create a new schema with exactly the types
                    you want. See the instructions above <a href="#modify_starting_schema"><em>Modify
                        a starting schema</em></a>. As an example, suppose your new schema is called
                    <span class="code">user.myschema.schema</span>.
                </p>
            </li>
            <li>
                <p><strong>Set as starting schema.</strong> Set your new schema as the starting schema with
                    whatever database binding you are working with (generally, <span class="code">wx_binding</span>).
                    For example:</p>
                <pre class="tty">[DataBindings]

    [[wx_binding]]
        database = archive_sqlite
        table_name = archive
        manager = weewx.manager.DaySummaryManager
        <span class="highlight">schema = user.myschema.schema</span></pre>
            </li>
            <li>
                <p>
                    <strong>Check permissions.</strong> The reconfiguration utility will create a new database with the
                    same name as the old, except with the suffix <span class="code">_new</span> attached to the end.
                    Make sure you have the necessary permissions to do this. In particular, if you are using MySQL, you
                    will need <span class="code">CREATE</span> privileges.
                </p>
            </li>
            <li>
                <p>
                    <strong>Create and populate the new database.</strong> Use the utility
                    <span class="code">wee_database</span> with the <span class="code">--reconfigure</span> option.
                </p>
                <pre class="tty cmd">wee_database weewx.conf --reconfigure</pre>
                <p>
                    This will create a new database (nominally, <span class="code">weewx.sdb_new</span> if you are using
                    SQLite, <span class="code">weewx_new</span> if you are using MySQL), using the schema found in <span
                    class="code">user.myschema.schema</span>, and populate it with data from the old database.
                </p>
            </li>
            <li>
                <p>
                    <strong>Shuffle the databases.</strong> Now arrange things so WeeWX can find the new database.
                </p>

                <p class="warning">
                    <strong>Warning!</strong><br/> Make a backup of the data before doing any of the next steps!
                </p>

                <p>
                    You can either shuffle the databases around so the new database has the same name as the old
                    database, or edit <span class="code">weewx.conf</span> to use the new database name. To do the
                    former:
                </p>

                <p>For SQLite:</p>
                <pre class="tty cmd">cd <span class="symcode">SQLITE_ROOT</span>
mv weewx.sdb_new weewx.sdb</pre>
                <p>For MySQL:</p>
                <pre class="tty"><span class="cmd">mysql -u &lt;username&gt; --password=&lt;mypassword&gt;</span>
mysql&gt;<span class="cmd"> DROP DATABASE weewx;</span>                             # Delete the old database
mysql&gt;<span class="cmd"> CREATE DATABASE weewx;</span>                           # Create a new one with the same name
mysql&gt;<span class="cmd"> RENAME TABLE weewx_new.archive TO weewx.archive;</span> # Rename to the nominal name</pre>
            </li>
            <li>
                <p>
                    It's worth noting that there's actually a hidden, last step: rebuilding the daily summaries inside
                    the new database. This will be done automatically by WeeWX at the next startup. Alternatively, it
                    can be done manually using the <a href="utilities.htm#wee_database_utility"><span class="code">wee_database</span></a>
                    utility and the <span class="code">--rebuild-daily</span> option:
                </p>
                <pre class="tty cmd">wee_database weewx.conf --rebuild-daily</pre>
            </li>
        </ol>


        <h2 id="Changing_the_unit_system">Changing the unit system in an existing database</h2>
        <p>
            Normally, data are stored in the databases using US Customary units, and you shouldn't care; it is an
            "implementation detail". Data can always be displayed using any set of units you want &mdash; the section <a
            href="#how_to_change_units"><em>How to change units</em></a> explains how to change the reporting units.
            Nevertheless, there may be special situations where you wish to store the data in Metric units. For example,
            you may need to allow direct programmatic access to the database from another piece of software that expects
            metric units.
        </p>

        <p>
            You should not change the database unit system midstream. That is, do not start with one unit system then,
            some time later, switch to another. WeeWX cannot handle databases with mixed unit systems &mdash; see the
            section <span class="code"> <a href="usersguide.htm#StdConvert">[StdConvert]</a></span> in the WeeWX User's
            Guide. However, you can reconfigure the database by copying it to a new database, performing the unit
            conversion along the way. You then use this new database.
        </p>

        <p>
            The general strategy is identical to the strategy outlined above in the section
            <a href="#transfer_database_using_new_schema"><em>Transfer database using new schema</em></a>. The only
            difference is that instead of specifying a new starting schema, you specify a different database
            unit system.
            This means that instead of steps 1 and 2 above, you edit the configuration file and change
            option <span class="code">target_unit</span> in section <span class="code"><a
            href="usersguide.htm#StdConvert">[StdConvert]</a></span> to reflect your choice. For example, if you are
            switching to metric units, the option will look like:
        </p>
        <pre class="tty">[StdConvert]
    target_unit = METRICWX</pre>

        <p>
            After changing <span class="code">target_unit</span>, you then go ahead with the rest of the steps. That is
            run <span class="code">wee_database</span> with the <span class="code">--reconfigure</span> option, then
            shuffle the databases.
        </p>




        <h2>Rebuilding the daily summaries</h2>

        <p>
            The <span class="code">wee_database</span> utility can also be used to rebuild the daily summaries:
        </p>

        <pre class="tty cmd">wee_database weewx.conf --rebuild-daily</pre>

        <p>In most cases this will be sufficient; however, if anomalies remain in the daily summaries the daily summary
            tables may be dropped first before rebuilding:
        </p>

        <pre class="tty cmd">wee_database weewx.conf --drop-daily</pre>

        <p>
            The summaries will automatically be rebuilt the next time WeeWX starts, or they can be rebuilt with the
            utility:
        </p>

        <pre class="tty cmd">wee_database weewx.conf --rebuild-daily</pre>


        <!-- -------------------------------------------------------------- -->

        <h1 id="customizing_units">Customizing units and unit groups</h1>

        <p class="warning">
            <strong>Warning!</strong><br/> This is an area that is changing rapidly in WeeWX. Presently, new units and
            unit groups are added by manipulating the internal dictionaries in WeeWX (as described below). In the
            future, they may be specified in <span class='code'>weewx.conf</span>.
        </p>

        <h2>Assigning a unit group</h2>
        <p>
            In the examples above, we created a new observation type, <span class='code'>electricity</span>, and added
            it to the database schema. Now we would like to recognize that it is a member of the unit group <span
            class='code'>group_energy</span> (which already exists), so it can enjoy the labels and formats already
            provided for this group. This is done by extending the dictionary <span class='code'>weewx.units.obs_group_dict</span>.
        </p>

        <p>Add the following to our new services file <span class='code'>user/electricity.py</span>, just after the last
            import statement:
        </p>
        <pre class="tty">import weewx
from weewx.engine import StdService
<span class="highlight">
import weewx.units
weewx.units.obs_group_dict['electricity'] = 'group_energy'</span>

class AddElectricity(StdService):

   # [...]</pre>

        <p>When our new service gets loaded by the WeeWX engine, these few lines will get run. They tell WeeWX that our
            new observation type, <span class='code'>electricity</span>, is part of the unit group <span class='code'>group_energy</span>.
            Once the observation has been associated with a unit group, the unit labels and other tag syntax will work
            for that observation. So, now a tag like:
        </p>
        <pre class='tty'>$month.electricity.sum</pre>
        <p>will return the total amount of electricity consumed for the month, in Watt-hours.</p>

        <h2>Creating a new unit group</h2>
        <p>
            That was an easy one, because there was already an existing group, <span class='code'>group_energy</span>,
            that covered our new observation type. But, what if we are measuring something entirely new, like force with
            time? There is nothing in the existing system of units that covers things like newtons or pounds. We will
            have to define these new units, as well as the unit group they can belong to.
        </p>
        <p>
            We assume we have a new observation type, <span class='code'>rocketForce</span>, which we are measuring over time,
            for a service named <span class="code">Rocket</span>, located in <span class='code'>
        user/rocket.py</span>. We will create a new unit group, <span class='code'>group_force</span>, and new units,
            <span class='code'>newton</span> and <span class='code'>pound</span>. Our new observation, <span
            class='code'>rocketForce</span>, will belong to <span class='code'>group_force</span>, and will be measured in
            units of <span class='code'>newton</span> or <span class='code'>pound</span>.
        </p>
        <p>
            To make this work, we need to add the following to <span class="code">user/rocket.py</span>.
        </p>
        <ol>
            <li>As before, we start by specifying what group our new observation type belongs to:
                <pre class='tty'>
import weewx.units
weewx.units.obs_group_dict['rocketForce'] = 'group_force'</pre>
            </li>
            <li>Next, we specify what unit is used to measure force in the three standard unit systems used by weewx.
                <pre class='tty'>
weewx.units.USUnits['group_force'] = 'pound'
weewx.units.MetricUnits['group_force'] = 'newton'
weewx.units.MetricWXUnits['group_force'] = 'newton'</pre>
            </li>
            <li>Then we specify what formats and labels to use for <span class='code'>newton</span> and <span
                class='code'>pound</span>:
                <pre class='tty'>
weewx.units.default_unit_format_dict['newton'] = '%.1f'
weewx.units.default_unit_format_dict['pound']  = '%.1f'

weewx.units.default_unit_label_dict['newton'] = ' newton'
weewx.units.default_unit_label_dict['pound']  = ' pound'</pre>
            </li>
            <li>Finally, we specify how to convert between them:
                <pre class='tty'>
weewx.units.conversionDict['newton'] = {'pound':  lambda x : x * 0.224809}
weewx.units.conversionDict['pound']  = {'newton': lambda x : x * 4.44822}
</pre>

            </li>
        </ol>
        <p>
            Now, when the service <span class="code">Rocket</span> gets loaded, these lines of code will get executed,
            adding the necessary unit extensions to WeeWX.
        </p>

        <h2>Using the new units</h2>

        <p>Now you've added a new type of units. How do you use it?</p>

        <p>
            Pretty much like any other units. For example, to do a plot of the month's electric consumption, totaled by
            day, add this section to the <span class="code">[[month_images]]</span> section of <span class="code">skin.conf</span>:
        </p>
        <pre class="tty">[[[monthelectric]]]
    [[[[electricity]]]]
        aggregate_type = sum
        aggregate_interval = day
        label = Electric consumption (daily total)</pre>
        <p>
            This will cause the generation of an image <span class="code">monthelectric.png</span>, showing a plot of
            each day's consumption for the past month.
        </p>

        <p>If you wish to use the new type in the templates, it will be available using the same syntax as any other
            type. Here are some other tags that might be useful:
        </p>
        <table class="indent">
            <tbody>
            <tr class="first_row">
                <td>Tag</td>
                <td>Meaning</td>
            </tr>
            <tr>
                <td class="code">$day.electricity.sum</td>
                <td>Total consumption since midnight</td>
            </tr>
            <tr>
                <td class="code">$year.electricity.sum</td>
                <td>Total consumption since the first of the year</td>
            </tr>
            <tr>
                <td class="code">$year.electricity.max</td>
                <td>The most consumed during any archive period</td>
            </tr>
            <tr>
                <td class="code">$year.electricity.maxsum</td>
                <td>The most consumed during a day</td>
            </tr>
            <tr>
                <td class="code">$year.electricity.maxsumtime</td>
                <td>The day it happened.</td>
            </tr>
            <tr>
                <td class="code">$year.electricity.sum_ge((5000.0, 'kWh', 'group_energy'))</td>
                <td>The number of days of the year where more than 5.0 kWh of energy was consumed. The argument
                    is a <span class="code">ValueTuple</span>.
                </td>
            </tr>
            </tbody>
        </table>


        <!-- -------------------------------------------------------------- -->

        <h1>Adding new, derived types</h1>
        <p>
            In the section <a href="#Adding_2nd_source"><em>Adding a second data source</em></a>, we saw an example of
            how to create a new type for a new data source. But, what if you just want to add a type that is a
            derivation of existing types? The WeeWX type <span class="code">dewpoint</span> is an example of this: it's
            a function of two observables, <span class="code">outTemp</span>, and <span class="code">outHumidity</span>.
            WeeWX calculates it automatically for you.
        </p>
        <p>
            Calculating new, derived types is the job of the WeeWX XTypes system. It can also allow you to add new
            aggregatioin types.
        </p>
        <p>
            See the Wiki article <a href="https://github.com/weewx/weewx/wiki/WeeWX-V4-user-defined-types"><em>WeeWX V4
            user defined types</em></a> for complete details on how the XTypes system works.
        </p>

        <!-- -------------------------------------------------------------- -->

        <h1 id="porting">Porting to new hardware</h1>

        <p>Naturally, this is an advanced topic but, nevertheless, I'd like to encourage any Python wizards out there to
            give it a try. Of course, I have selfish reasons for this: I don't want to have to buy every weather station
            ever invented, and I don't want my roof to look like a weather station farm!
        </p>

        <p>
            A <em>driver</em> communicates with hardware. Each driver is a single python file that contains the code
            that is the interface between a device and WeeWX. A driver may communicate directly with hardware using a
            MODBus, USB, serial, or other physical interface. Or it may communicate over a network to a physical device
            or a web service.
        </p>

        <h2>General guidelines</h2>

        <ul>
            <li>The driver should emit data as it receives it from the hardware (no caching).
            </li>
            <li>The driver should emit only data it receives from the hardware (no "filling in the gaps").
            </li>
            <li>The driver should not modify the data unless the modification is directly related to the hardware (<i>e.g.</i>,
                decoding a hardware-specific sensor value).
            </li>
            <li>If the hardware flags "bad data", then the driver should emit a null value for that datum (Python <span
                class="code">None</span>).
            </li>
            <li>The driver should not calculate any derived variables (such as dewpoint). The service <span
                class="code">StdWXService</span> will do that.
            </li>
            <li>However, if the hardware emits a derived variable, then the driver should emit it.
            </li>
        </ul>

        <h2>Implement the driver</h2>

        <p>
            Create a file in the user directory, say <span class="code">mydriver.py</span>. This file will contain the
            driver class as well as any hardware-specific code. Do not put it in the <span
            class="code">weewx/drivers</span> directory or it will be deleted when you upgrade WeeWX.
        </p>

        <p>
            Inherit from the abstract base class <span class="code">weewx.drivers.AbstractDevice</span>. Try to
            implement as many of its methods as you can. At the very minimum, you must implement the first three
            methods, <span class="code">loader</span>, <span class="code">hardware_name</span>, and <span class="code">genLoopPackets</span>.
        </p>

        <h3>
            <span class="code">loader</span>
        </h3>

        <p>This is a factory function that returns an instance of your driver. It has two arguments: the configuration
            dictionary, and a reference to the WeeWX engine.
        </p>

        <h3>
            <span class="code">hardware_name</span>
        </h3>

        <p>
            Return a string with a short nickname for the hardware, such as <span class="code">"ACME X90"</span>
        </p>

        <h3>
            <span class="code">genLoopPackets</span>
        </h3>

        <p>
            This should be a Python <a href="https://wiki.python.org/moin/Generators">generator function</a> that yields
            loop packets, one after another. Don't worry about stopping it: the engine will do this when an archive
            record is due. A "loop packet" is a dictionary. At the very minimum it must contain keys for the observation
            time and for the units used within the packet.
        </p>
        <table class="indent" style="width: 60%">
            <caption>Required keys</caption>
            <tbody>
            <tr>
                <td class="code first_col">dateTime</td>
                <td>The time of the observation in unix epoch time.</td>
            </tr>
            <tr>
                <td class="code first_col">usUnits</td>
                <td>
                    The unit system used. <span class="code">weewx.US</span> for US customary, <span
                    class="code">weewx.METRICWX</span>, or <span class="code">weewx.METRIC</span> for metric. See the
                    Appendix <a href="#units"><em>Units</em></a> for their exact definitions. The dictionaries <span
                    class="code">USUnits</span>, <span class="code">MetricWXUnits</span>, and <span
                    class="code">MetricUnits</span> in file <span class="code">units.py</span>, can also be useful.
                </td>
            </tr>
            </tbody>
        </table>
        <p>
            Then include any observation types you have in the dictionary. Every packet need not contain the same set of
            observation types. Different packets can use different unit systems, but all observations within a packet
            must use the same unit system. If your hardware is capable of measuing an observation type but, for whatever
            reason, its value is bad (maybe a bad checksum?), then set its value to <span class="code">None</span>. If
            your hardware is incapable of measuring an observation type, then leave it out of the dictionary.
        </p>

        <p>
            A couple of observation types are tricky, in particular, <span class="code">rain</span>. The field <span
            class="code">rain</span> in a LOOP packet should be the amount of rain that has fallen <em>since the last
            packet</em>. Because LOOP packets are emitted fairly frequently, this is likely to be a small number. If
            your hardware does not provide this value, you might have to infer it from changes in whatever value it
            provides, for example changes in the daily or monthly rainfall.
        </p>

        <p>
            Wind is another tricky one. It is actually broken up into four different observations: <span class="code">windSpeed</span>,
            <span class="code">windDir</span>, <span class="code">windGust</span>, and <span
            class="code">windGustDir</span>. Supply as many as you can. The directions should be compass directions in
            degrees (0=North, 90=East, etc.).
        </p>

        <p>Be careful when reporting pressure. There are three observations related to pressure. Some stations report
            only the station pressure, others calculate and report sea level pressures.
        </p>
        <table class="indent" style="width: 60%">
            <caption>Pressure types</caption>
            <tbody>
            <tr>
                <td class="code first_col">pressure</td>
                <td>The <em>Station Pressure</em> (SP), which is the raw, absolute pressure measured by the station.
                    This is the true barometric pressure for the station.
                </td>
            </tr>
            <tr>
                <td class="code first_col">barometer</td>
                <td>The <em>Sea Level Pressure</em> (SLP) obtained by correcting the <em>Station Pressure</em> for
                    altitude and local temperature. This is the pressure reading most commonly used by meteorologist to
                    track weather systems at the surface, and this is the pressure that is uploaded to weather services
                    by WeeWX. It is the station pressure reduced to mean sea level using local altitude and local
                    temperature.
                </td>
            </tr>
            <tr>
                <td class="code first_col">altimeter</td>
                <td>The <em>Altimeter Setting</em> (AS) obtained by correcting the <em>Station Pressure</em> for
                    altitude. This is the pressure reading most commonly heard in weather reports. It is not the true
                    barometric pressure of a station, but rather the station pressure reduced to mean sea level using
                    altitude and an assumed temperature average.
                </td>
            </tr>
            </tbody>
        </table>

        <h3>
            <span class="code">genArchiveRecords()</span>
        </h3>

        <p>
            If your hardware does not have an archive record logger, then WeeWX can do the record generation for you. It
            will automatically collect all the types it sees in your loop packets then emit a record with the averages
            (in some cases the sum or max value) of all those types. If it doesn't see a type, then it won't appear in
            the emitted record.
        </p>

        <p>
            However, if your hardware does have a logger, then you should implement method <span class="code">genArchiveRecords()</span>
            as well. It should be a generator function that returns all the records since a given time.
        </p>

        <h3>
            <span class="code">archive_interval</span>
        </h3>

        <p>
            If you implement function <span class="code">genArchiveRecords()</span>, then you should also implement
            <span class='code'>archive_interval</span> as either an attribute, or as a <a
            href="https://docs.python.org/3/library/functions.html#property">property function</a>. It should return the
            archive interval in seconds.
        </p>

        <h3>
            <span class="code">getTime()</span>
        </h3>

        <p>If your hardware has an onboard clock and supports reading the time from it, then you may want to implement
            this method. It takes no argument. It should return the time in Unix Epoch Time.
        </p>

        <h3>
            <span class="code">setTime()</span>
        </h3>

        <p>
            If your hardware has an onboard clock and supports <em>setting</em> it, then you may want to implement this
            method. It takes no argument and does not need to return anything.
        </p>

        <h3>
            <span class="code">closePort()</span>
        </h3>

        <p>
            If the driver needs to close a serial port, terminate a thread, close a database, or perform any other
            activity before the application terminates, then you must supply this function. WeeWX will call it if it
            needs to shut down your console (usually in the case of an error).
        </p>

        <h2>Define the configuration</h2>

        <p>
            You then include a new section in the configuration file <span class="code">weewx.conf</span> that includes
            any options your driver needs. It should also include an entry <span class="code">driver</span> that points
            to where your driver can be found. Set option <span class="code">station_type</span> to your new section
            type and your driver will be loaded.
        </p>

        <h2>Examples</h2>

        <p>
            The <span class='code'>fileparse</span> driver is perhaps the simplest example of a WeeWX driver. It reads
            name-value pairs from a file and uses the values as sensor 'readings'. The code is actually packaged as an
            extension, located in <span class="code">examples/fileparse</span>, making it a good example of not only
            writing a device driver, but also of how to package an extension. The actual driver itself is in <span
            class="code">examples/fileparse/bin/user/fileparse.py</span>.
        </p>

        <p>
            Another good example is the simulator code located in <span class='code'>weewx/drivers/simulator.py</span>.
            It's dirt simple and you can easily play with it. Many people have successfully used it as a starting point
            for writing their own custom driver.
        </p>

        <p>
            The Ultimeter (<span class="code">ultimeter.py</span>) and WMR100 (<span class="code">wmr100.py</span>)
            drivers illustrate how to communicate with serial and USB hardware, respectively. They also show different
            approaches for decoding data. Nevertheless, they are pretty straightforward.
        </p>

        <p>
            The driver for the Vantage series is by far the most complicated. It actually multi-inherits from not only
            <span class="code">AbstractDevice</span>, but also <span class="code">StdService</span>. That is, it also
            participates in the engine as a service.
        </p>

        <p>Naturally, there are a lot of subtleties that have been glossed over in this high-level description. If you
            run into trouble, look for help in the <a href="https://groups.google.com/forum/#!forum/weewx-development">
                <span class="code">weewx-development</span> forum</a>.
        </p>

        <!-- -------------------------------------------------------------- -->

        <h1 id="extensions">Extensions</h1>

        <p>
            A key feature of WeeWX is its ability to be extended by installing 3rd party <em>extensions</em>. Extensions
            are a way to package one or more customizations so they can be installed and distributed as a functional
            group.
        </p>

        <p>Customizations typically fall into one of these categories:</p>
        <ul>
            <li>search list extension</li>
            <li>template</li>
            <li>skin</li>
            <li>service</li>
            <li>generator</li>
            <li>driver</li>
        </ul>

        <p>
            Take a look at the <a href="https://github.com/weewx/weewx/wiki"> WeeWX wiki </a> for a sampling of some of
            the extensions that are available.
        </p>


        <!-- Utility wee_extension moved to utilities.htm -->


        <h2>Creating an extension</h2>

        <p>
            Now that you have made some customizations, you might want to share those changes with other WeeWX users.
            Put your customizations into an extension to make installation, removal, and distribution easier.
        </p>

        <p>Here are a few guidelines for creating extensions:</p>
        <ul>
            <li>Extensions should not modify or depend upon existing skins. An extension should include its own,
                standalone skin to illustrate any templates, search list extension, or generator features.
            </li>
            <li>Extensions should not modify the database schemas. If it requires data not found in the default
                databases, an extension should provide its own database and schema.
            </li>
        </ul>

        <p>
            Although one extension might use another extension, take care to write the dependent extension so that it
            fails gracefully. For example, a skin might use data the forecast extension, but what happens if the
            forecast extension is not installed? Make the skin display a message about "forecast not installed" but
            otherwise continue to function.
        </p>

        <h2>Packaging an extension</h2>

        <p>
            The structure of an extension mirrors that of WeeWX itself. If the customizations include a skin, the
            extension will have a skins directory. If the customizations include python code, the extension will have a
            <span class='code'>bin/user</span> directory.
        </p>

        <p>Each extension should also include:</p>
        <ul>
            <li><span class='code'>readme.txt</span> - a summary of what the extension does, list of pre-requisites (if
                any), and instructions for installing the extension manually
            </li>
            <li><span class='code'>changelog</span> - an enumeration of changes in each release
            </li>
            <li><span class='code'>install.py</span> - python code used by the WeeWX ExtensionInstaller
            </li>
        </ul>
        <p>
            For example, here is the structure of a skin called <span class='code'>basic</span>:
        </p>

        <pre class='tty'>basic/
basic/changelog
basic/install.py
basic/readme.txt
basic/skins/
basic/skins/basic/
basic/skins/basic/basic.css
basic/skins/basic/current.inc
basic/skins/basic/favicon.ico
basic/skins/basic/hilo.inc
basic/skins/basic/index.html.tmpl
basic/skins/basic/skin.conf</pre>

        <p>
            Here is the structure of a search list extension called <span class='code'>xstats</span>:
        </p>

        <pre class='tty'>xstats/
xstats/changelog
xstats/install.py
xstats/readme.txt
xstats/bin/
xstats/bin/user/
xstats/bin/user/xstats.py</pre>

        <p>
            See the <span class='code'>extensions</span> directory of the WeeWX source for examples.
        </p>

        <p>To distribute an extension, simply create a compressed archive of the extension directory.</p>

        <p>
            For example, create the compressed archive for the <span class='code'>basic</span> skin like this:
        </p>

        <p class='tty cmd'>tar cvfz basic.tar.gz basic</p>

        <p>Once an extension has been packaged, it can be installed using the <a
            href="utilities.htm#wee_extension_utility">wee_extension</a> utility.
        </p>

        <h2>Default values</h2>

        <p>
            Whenever possible, an extension should <em>just work</em>, with a minimum of input from the user. At the
            same time, parameters for the most frequently requested options should be easily accessible and easy to
            modify. For skins, this might mean parameterizing strings into <span class="code">[Labels]</span> for easier
            customization. Or it might mean providing parameters in <span class="code">[Extras]</span> to control skin
            behavior or to parameterize links.
        </p>
        <p>
            Some parameters <em>must</em> be specified, and no default value would be appropriate. For example, an
            uploader may require a username and password, or a driver might require a serial number or IP address. In
            these cases, use a default value in the configuration that will obviously require modification. The <em>username</em>
            might default to <em>REPLACE_ME</em>. Also be sure to add a log entry that indicates the feature is disabled
            until the value has been specified.
        </p>
        <p>
            In the case of drivers, use the configuration editor to prompt for this type of required value.
        </p>


        <!-- -------------------------------------------------------------- -->

        <h1 id="report_options">Reference: report options</h1>

        <p>
            This section contains the options available in the skin configuration file, <span
            class="code">skin.conf</span>. The same options apply to the
            language files found in the subdirectory
            <span class="code">lang</span>, like
            <span class="code">lang/en.conf for English</span>.
        </p>
        <p>
            We recommend to put
        </p>
            <ul>
              <li>
                options that control the behavior of the skin into
                <span class="code">skin.conf</span>; and
              </li>
              <li>
                language dependent labels and texts into the
                language files.
              </li>
            </ul>

        <p>
            The most important options, the ones you are likely to have to customize, are <span
            class="config_important"><strong>highlighted</strong></span>.
        </p>

        <p>
            It is worth noting that, like the main configuration file <span class="code">weewx.conf</span>, UTF-8 is
            used throughout.
        </p>


        <h2 class="config_section" id="Extras">[Extras]</h2>

        <p>This section is available to add any static tags you might want to use in your templates.</p>

        <p>
            As an example, the <span class="code">skin.conf</span> file for the <em>Seasons</em> skin includes three
            options:
        </p>
        <table class="indent" style="width: 50%">
            <tr class="first_row">
                <td>Skin option</td>
                <td>Template tag</td>
            </tr>
            <tr>
                <td class="code">radar_img</td>
                <td class="code">$Extras.radar_img</td>
            </tr>
            <tr>
                <td class="code">radar_url</td>
                <td class="code">$Extras.radar_url</td>
            </tr>
            <tr>
                <td class="code">googleAnalyticsId</td>
                <td class="code">$Extras.googleAnalyticsId</td>
            </tr>
        </table>
        <p>
            If you take a look at the template <span class="code">radar.inc</span> you will see examples of testing for
            these tags.
        </p>

        <p class="config_option">radar_img</p>

        <p>Set to an URL to show a local radar image for your region.</p>

        <p class="config_option">radar_url</p>

        <p>If the radar image is clicked, the browser will go to this URL. This is usually used to show a more detailed,
            close-up, radar picture.
        </p>

        <p>For me in Oregon, setting the two options to:</p>
        <pre class="tty">
[Extras]
    radar_img = http://radar.weather.gov/ridge/lite/N0R/RTX_loop.gif
    radar_url = http://radar.weather.gov/ridge/radar.php?product=NCR&amp;rid=RTX&amp;loop=yes</pre>
        <p>
            results in a nice image of a radar centered on Portland, Oregon. When you click on it, it gives you a
            detailed, animated view. If you live in the USA, take a look at the <a href="http://radar.weather.gov/">NOAA
            radar website</a> to find a nice one that will work for you. In other countries, you will have to consult
            your local weather service.
        </p>

        <p class="config_option">googleAnalyticsId</p>

        <p>
            If you have a <a href="https://www.google.com/analytics/">Google Analytics ID</a>, you can set it here. The
            Google Analytics Javascript code will then be included, enabling analytics of your website usage. If
            commented out, the code will not be included.
        </p>

        <h3>
            Extending <span class="code">[Extras]</span>
        </h3>

        <p>Other tags can be added in a similar manner, including sub-sections. For example, say you have added a video
            camera and you would like to add a still image with a hyperlink to a page with the video. You want all of
            these options to be neatly contained in a sub-section.
        </p>
        <pre class="tty">[Extras]
    [[video]]
        still = video_capture.jpg
        hyperlink = http://www.eatatjoes.com/video.html
      </pre>
        <p>Then in your template you could refer to these as:</p>
        <pre class="tty">&lt;a href="$Extras.video.hyperlink"&gt;
    &lt;img src="$Extras.video.still" alt="Video capture"/&gt;
&lt;/a&gt;</pre>

        <h2 class="config_section">[Labels]</h2>

        <p>This section defines various labels.</p>

        <p class="config_option">hemispheres</p>

        <p>
            Comma separated list for the labels to be used for the four hemispheres. The default is <span class="code">N, S, E, W</span>.
        </p>

        <p class="config_option">latlon_formats</p>

        <p>Comma separated list for the formatting to be used when converting latitude and longitude to strings. There
            should be three elements:
        </p>
        <ol>
            <li>The format to be used for whole degrees of latitude</li>
            <li>The format to be used for whole degrees of longitude</li>
            <li>The format to be used for minutes.</li>
        </ol>
        <p>This allows you to decide whether or not you want leading zeroes. The default includes leading zeroes and is
            &quot;%02d&quot;, &quot;%03d&quot;, &quot;%05.2f&quot;
        </p>

        <h3 class="config_section" id="Labels_Generic">[[Generic]]</h3>

        <p>This sub-section specifies default labels to be used for each observation type. For example, options</p>
        <pre class="tty">inTemp  = Temperature inside the house
outTemp = Outside Temperature
UV      = UV Index</pre>
        <p>
            would cause the given labels to be used for plots of <span class="code">inTemp</span> and <span
            class="code">outTemp</span>. If no option is given, then the observation type itself will be used
            (<i>e.g.</i>, <span class="code">outTemp</span>).
        </p>

        <h2 class="config_section">[Almanac]</h2>

        <p>This section controls what text to use for the almanac. It consists of only one entry</p>

        <p class="config_option">moon_phases</p>

        <p>
            This option is a comma separated list of labels to be used for the eight phases of the moon. Default is
            <span class="code">New,
          Waxing crescent, First quarter, Waxing gibbous, Full, Waning
          gibbous, Last quarter, Waning crescent</span>.
        </p>

        <h2 class="config_section">[Units]</h2>

        <p>This section controls how units are managed and displayed.</p>

        <h3 class="config_section">[[Groups]]</h3>

        <p>
            This sub-section lists all the <em>Unit Groups</em> and specifies which measurement unit is to be used for
            each one of them.
        </p>

        <p>
            As there are many different observational measurement types (such as <span class="code">outTemp</span>,
            <span class="code">barometer</span>, etc.) used in WeeWX (more than 50 at last count), it would be tedious,
            not to say possibly inconsistent, to specify a different measurement system for each one of them. At the
            other extreme, requiring all of them to be "U.S. Customary" or "Metric" seems overly restrictive. WeeWX has
            taken a middle route and divided all the different observation types into 12 different <em>unit groups</em>.
            A unit group is something like <span class="code">group_temperature</span>. It represents the measurement
            system to be used by all observation types that are measured in temperature, such as inside temperature
            (type <span class="code">inTemp</span>), outside temperature (<span class="code">outTemp</span>), dewpoint (<span
            class="code">dewpoint</span>), wind chill (<span class="code">windchill</span>), and so on. If you decide
            that you want unit group <span class="code">group_temperature</span> to be measured in <span class="code">degree_C</span>
            then you are saying <em>all</em> members of its group will be reported in degrees Celsius.
        </p>

        <p>
            Note that the measurement unit is always specified in the singular. That is, specify <span
            class="code">degree_C</span> or <span class="code">foot</span>, not <span class="code">degrees_C</span> or
            <span class="code">feet</span>. See the <em><a href="#units">Appendix: Units</a></em> for more information,
            including a concise summary of the groups, their members, and which options can be used for each group.
        </p>

        <p class="config_important">
            <a class="config_option" id="group_altitude">group_altitude</a>
        </p>

        <p>
            Which measurement unit to be used for altitude. Possible options are <span class="code">foot</span> or <span
            class="code">meter</span>.
        </p>

        <p class="config_option">group_direction</p>

        <p>
            Which measurement unit to be used for direction. The only option is <span class="code">degree_compass</span>.
        </p>

        <p class="config_option">group_distance</p>

        <p>
            Which measurement unit to be used for distance (such as for wind run). Possible options are <span
            class="code">mile</span> or <span class="code">km</span>.
        </p>

        <p class="config_option">group_moisture</p>

        <p>
            The measurement unit to be used for soil moisture. The only option is <span class="code">centibar</span>.
        </p>

        <p class="config_option">group_percent</p>

        <p>
            The measurement unit to be used for percentages. The only option is <span class="code">percent</span>.
        </p>

        <p class="config_important">group_pressure</p>

        <p>
            The measurement unit to be used for pressure. Possible options are one of <span class="code">inHg</span>
            (inches of mercury), <span class="code">mbar</span>, <span class="code">hPa</span>, or <span class="code">kPa</span>.
        </p>

        <p class="config_important">group_pressurerate</p>

        <p>
            The measurement unit to be used for rate of change in pressure. Possible options are one of
            <span class="code">inHg_per_hour</span> (inches of mercury per hour),
            <span class="code">mbar_per_hour</span>, <span class="code">hPa_per_hour</span>,
            or <span class="code">kPa_per_hour</span>.
        </p>

        <p class="config_option">group_radiation</p>

        <p>
            The measurement unit to be used for radiation. The only option is <span
            class="code">watt_per_meter_squared</span>.
        </p>

        <p class="config_important">group_rain</p>

        <p>
            The measurement unit to be used for precipitation. Options are <span class="code">inch</span>, <span
            class="code">cm</span>, or <span class="code">mm</span>.
        </p>

        <p class="config_important">group_rainrate</p>

        <p>
            The measurement unit to be used for rate of precipitation. Possible options are one of <span class="code">inch_per_hour</span>,
            <span class="code">cm_per_hour</span>, or <span class="code">mm_per_hour</span>.
        </p>

        <p class="config_important">group_speed</p>

        <p>
            The measurement unit to be used for wind speeds. Possible options are one of <span class="code">mile_per_hour</span>,
            <span class="code">km_per_hour</span>, <span class="code">knot</span>, <span class="code">meter_per_second</span>,
            or <span class="code">beaufort</span>.
        </p>

        <p class="config_important">group_speed2</p>

        <p>
            This group is similar to <span class="code">group_speed</span>, but is used for calculated wind speeds which
            typically have a slightly higher resolution. Possible options are one <span
            class="code">mile_per_hour2</span>, <span class="code">km_per_hour2</span>, <span class="code">knot2</span>,
            or <span class="code">meter_per_second2</span>.
        </p>

        <p>
            <a class="config_important" id="group_temperature">group_temperature</a>
        </p>

        <p>
            The measurement unit to be used for temperatures. Options are <span class="code">degree_C</span>,
            <span class="code"><a href="https://xkcd.com/1923/">degree_E</a></span>, <span
            class="code">degree_F</span>, or <span class="code">degree_K</span>.
        </p>

        <p class="config_option">group_volt</p>

        <p>
            The measurement unit to be used for voltages. The only option is <span class="code">volt</span>.
        </p>

        <h3 class="config_section" id="Units_StringFormats">[[StringFormats]]</h3>

        <p>This sub-section is used to specify what string format is to be used for each unit when a quantity needs to
            be converted to a string. Typically, this happens with y-axis labeling on plots and for statistics in HTML
            file generation. For example, the options
        </p>
        <pre class="tty">degree_C = %.1f
inch     = %.2f</pre>
        <p>
            would specify that the given string formats are to be used when formatting any temperature measured in
            degrees Celsius or any precipitation amount measured in inches, respectively. The <a
            href="https://docs.python.org/library/string.html#format-specification-mini-language"> formatting codes are
            those used by Python</a>, and are very similar to C's <span class="code">sprintf()</span> codes.
        </p>

        <p>
            You can also specify what string to use for an invalid or unavailable measurement (value <span class="code">None</span>).
            For example,
        </p>
        <pre class="tty">NONE = " N/A "</pre>

        <h3 class="config_section" id="Units_Labels">[[Labels]]</h3>

        <p>This sub-section specifies what label is to be used for each measurement unit type. For example, the options
        </p>
        <pre class="tty">degree_F = F
inch     = ' in'</pre>
        <p>
            would cause all temperatures to have unit labels <span class="code">F</span> and all precipitation to have
            labels <span class="code">in</span>. If any special symbols are to be used (such as the degree sign) they
            should be encoded in UTF-8. This is generally what most text editors use if you cut-and-paste from a
            character map.
        </p>

        <p>If the label includes two values, then the first is assumed to be the singular form, the second the plural
            form. For example,
        </p>
        <pre class="tty">foot   = " foot",   " feet"
...
day    = " day",    " days"
hour   = " hour",   " hours"
minute = " minute", " minutes"
second = " second", " seconds"</pre>

        <h3 class="config_section" id="Units_TimeFormats">[[TimeFormats]]</h3>

        <p>
            This sub-section specifies what time format to use for different time <em>contexts</em>. For example, you
            might want to use a different format when displaying the time in a day, versus the time in a month. It uses
            <a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior">strftime()</a> formats.
            The default looks like this:
        </p>
        <pre class='tty'>
    [[TimeFormats]]
        hour        = %H:%M
        day         = %X
        week        = %X (%A)
        month       = %x %X
        year        = %x %X
        rainyear    = %x %X
        current     = %x %X
        ephem_day   = %X
        ephem_year  = %x %X
</pre>

        <p>
            The specifiers <span class='code'>%x</span>, <span class='code'>%X</span>, and <span class='code'>%A</span>
            code locale dependent date, time, and weekday names, respectively. Hence, if you set an appropriate
            environment variable <span class='code'>LANG</span>, then the date and times should follow local conventions
            (see section <a href="#environment_variable_LANG">Environment variable LANG</a> for details on how to do
            this). However, the results may not look particularly nice, and you may want to change them. For example,
            I use this in the U.S.:
        </p>
        <pre class="tty">
    [[TimeFormats]]
        #
        # More attractive formats that work in most Western countries.
        #
        day        = %H:%M
        week       = %H:%M on %A
        month      = %d-%b-%Y %H:%M
        year       = %d-%b-%Y %H:%M
        rainyear   = %d-%b-%Y %H:%M
        current    = %d-%b-%Y %H:%M
        ephem_day  = %H:%M
        ephem_year = %d-%b-%Y %H:%M</pre>

        <p>
            The last two formats, <span class='code'>ephem_day</span> and <span class='code'>ephem_year</span> allow the
            formatting to be set for almanac times The first, <span class="code">ephem_day</span>, is used for almanac
            times within the day, such as sunrise or sunset. The second, <span class="code">ephem_year</span>, is used
            for almanac times within the year, such as the next equinox or full moon.
        </p>

        <h3 class="config_section" id="Units_Ordinates">[[Ordinates]]</h3>

        <p class="config_option">directions</p>

        <p>
            Set to the abbreviations to be used for ordinal directions. By default, this is <span class="code">N, NNE, NE, ENE, E,
          ESE, SE, SSE, S, SSW, SW, WSW, W, WNW, NW, NNW, N</span>.
        </p>

        <h3 class="config_section">[[DegreeDays]]</h3>

        <p class="config_important">
            heating_base <br/> cooling_base <br/> growing_base
        </p>

        <p>Set to the base temperature for calculating heating, cooling, and growing degree-days, along with the unit to
            be used. Examples:
        </p>
        <pre class="tty">heating_base = 65.0, degree_F
cooling_base = 20.0, degree_C
growing_base = 50.0, degree_F</pre>
        <h3 class="config_section" id="trend">[[Trend]]</h3>

        <p class="config_option">time_delta</p>

        <p>Set to the time difference over which you want trends to be calculated. The default is 3 hours.</p>

        <p class="config_option">time_grace</p>

        <p>
            When searching for a previous record to be used in calculating a trend, a record within this amount of <span
            class="code">time_delta</span> will be accepted. Default is 300 seconds.
        </p>

        <h2 class="config_section" id="texts">[Texts]</h2>

        <p>
            The section <span class="code">[Texts]</span> holds static texts that are used in the templates. Generally
            there are multiple language files, one for each supported language, named by the language codes defined in
            <a href="https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes" target="_blank">ISO&nbsp;639-1</a>. The
            entries give the translation of the texts to the target language. For example,
        </p>
        <pre class="tty">[Texts]
    "Current Conditions" = "Aktuelle Werte"</pre>
        <p>
            would cause "Aktuelle Werte" to be used whereever <span class="code">$gettext("Current Conditions"</span>
            appeared. See the section on <a href="#Tag_$gettext"><span class="code">$gettext</span></a>.
        </p>
        <p class="warning">
          <strong>Note!</strong><br/>
          Strings that include commas must be included in single or
          double quotes.
        </p>

        <h2 id="CheetahGenerator">[CheetahGenerator]</h2>

        <p>This section contains the options for the Cheetah generator.
        It applies to <span class="code">skin.conf</span> only.</p>

        <p class="config_option">search_list</p>

        <p>
            This is the list of search list objects that will be scanned by the template engine, looking for tags. See
            the section <em><a href="#defining_new_tags">Defining new tags</a></em> and the <a
            href="https://cheetahtemplate.org/">Cheetah documentation</a> for details on search lists. If
            no <span class="config_option">search_list</span> is specified, a default list will be used.

        <p class="config_option">search_list_extensions</p>
        <p>
            This defines one or more search list objects that will be appended to the <span class="config_option">search_list</span>.
            For example, if you are using the "seven day" and "forecast" search list extensions, the option would
            look like
        </p>
        <pre class="tty">search_list_extensions = user.seven_day.SevenDay, user.forecast.ForecastVariables</pre>
        <p class="config_option" id='option_encoding'>encoding</p>

        <p>
            As Cheetah goes through the template, it substitutes strings for all tag values. This option controls which
            encoding to use for the new strings. The encoding can be chosen on a per file basis. All of the encodings
            listed in the Python documentation
            <a href="https://docs.python.org/3/library/codecs.html#standard-encodings"><em>Standard Encodings</em></a>
            are available, as well as these WeeWX-specific encodings:
        </p>
        <table class="indent">
            <tbody>
            <tr class="first_row">
                <td>Encoding</td>
                <td>Comments</td>
            </tr>
            <tr>
                <td class="code first_col">html_entities</td>
                <td>Non 7-bit characters will be represented as HTML entities (<i>e.g.</i>, the degree sign will be
                    represented as <span class="code">&amp;#176;</span>)
                </td>
            </tr>
            <tr>
                <td class="code first_col">strict_ascii</td>
                <td>Non 7-bit characters will be ignored.</td>
            </tr>
            <tr>
                <td class="code first_col">normalized_ascii</td>
                <td>Replace accented characters with non-accented analogs (<i>e.g.</i>, '' will be replaced with 'o').</td>
            </tr>
            </tbody>
        </table>
        <p>
            The encoding <span class="code">html_entities</span> is the default. Other common choices are <span
            class="code">utf8</span>, <span class="code">cp1252</span> (<em>a.k.a.</em> Windows-1252), and <span
            class="code">latin1</span>.
        </p>

        <p class="config_option" id="option_template">template</p>

        <p>
            The name of a template file. A template filename must end with <span class="code">.tmpl</span>. Filenames
            are case-sensitive. If the template filename has the letters <span class="code">YYYY</span>, <span
            class="code">MM</span>, <span class="code">WW</span> or <span class="code">DD</span> in its name, these will
            be substituted for the year, month, week and day of month, respectively. So, a template with the name <span
            class="code">summary-YYYY-MM.html.tmpl</span> would have name <span class="code">summary-2010-03.html</span>
            for the month of March, 2010.
        </p>

        <p class="config_option" id="generate_once">generate_once

        <p>
            When set to <span class="code">True</span>, the template is processed only on the first invocation of the
            report engine service. This feature is useful for files that do not change when data values change, such as
            HTML files that define a layout. The default is <span class="code">False</span>.
        </p>

        <p class="config_option" id="stale_age">stale_age</p>

        <p>
            File staleness age, in seconds. If the file is older than this age it will be generated from the template.
            If no <span class="code">stale_age</span> is specified, then the file will be generated every time the
            generator runs.
        </p>

        <p class="note" style="display: inline-block; width: 70%">
            <strong>Note</strong><br/>Precise control over when a <em><a href="usersguide.htm#Reports">report</a></em>
            is run is available through use of the <span class="code">report_timing</span> option in <span class="code">weewx.conf</span>.
            The <span class="code">report_timing</span> option uses a CRON-like setting to control precisely when a
            report is run. See the <em><a href="#customizing_gen_time">Scheduling reports</a></em> section for details
            on the <span class="code">report_timing</span> option.
        </p>

        <p class="config_option">[[SummaryByDay]]</p>

        <p>
            The <span class="code">SummaryByDay</span> section defines some special behavior. Each template in this
            section will be used multiple times, each time with a different per-day timespan. Be sure to include <span
            class="code">YYYY</span>, <span class="code">MM</span>, and <span class="code">DD</span> in the filename of
            any template in this section.
        </p>

        <p class="config_option">[[SummaryByMonth]]</p>

        <p>
            The <span class="code">SummaryByMonth</span> section defines some special behavior. Each template in this
            section will be used multiple times, each time with a different per-month timespan. Be sure to include <span
            class="code">YYYY</span> and <span class="code">MM</span> in the filename of any template in this section.
        </p>

        <p class="config_option">[[SummaryByYear]]</p>

        <p>
            The <span class="code">SummaryByYear</span> section defines some special behavior. Each template in this
            section will be used multiple times, each time with a different per-year timespan. Be sure to include <span
            class="code">YYYY</span> in the filename of any template in this section.
        </p>

        <h2 class="config_section" id="ImageGenerator">[ImageGenerator]</h2>

        <p>This section describes the various options available to the image generator.</p>

        <div class="image image-right">
            <img src="images/image_parts.png" alt="Part names in a WeeWX image"/>

            <div class="image_caption">Part names in a WeeWX image</div>
        </div>


        <h3>Overall options</h3>

        <p>These are options that affect the overall image.</p>

        <p class="config_option">anti_alias</p>

        <p>
            Setting to 2 or more might give a sharper image, with fewer jagged edges. Experimentation is in order.
            Default is <span class="code">1</span>.
        </p>

        <p class="config_option">chart_background_color</p>

        <p>
            The background color of the chart itself. Optional. Default is <span class='code'>#d8d8d8</span>.
        </p>

        <p class="config_option">chart_gridline_color</p>

        <p>
            The color of the chart grid lines. Optional. Default is <span class='code'>#a0a0a0</span>
        </p>

        <div class="image image-right" style="clear: right">
            <div class="image">
                <img src="images/antialias.gif" alt="Effect of anti_alias option"/>

                <div class="image_caption">
                    A GIF showing the same image with <span class="code">anti_alias=1</span>, <span
                    class="code">2</span>, and <span class="code">4</span>.
                </div>
            </div>
            <div class="image">
                <img src="images/weektempdew.png" alt="Example of day/night bands"/>

                <div class="image_caption">Example of day/night bands in a one week image
                </div>
            </div>
        </div>
        <p class="config_option">daynight_day_color</p>

        <p>
            The color to be used for the daylight band. Optional. Default is <span class="code">#ffffff</span>.
        </p>

        <p class="config_option">daynight_edge_color</p>

        <p>
            The color to be used in the transition zone between night and day. Optional. Default is <span class="code">#efefef</span>,
            a mid-gray.
        </p>

        <p class="config_option">daynight_night_color</p>

        <p>
            The color to be used for the nighttime band. Optional. Default is <span class="code">#f0f0f0</span>, a dark
            gray.
        </p>

        <p class="config_option">image_background_color</p>

        <p>
            The background color of the whole image. Optional. Default is <span class='code'>#f5f5f5</span>
            ("SmokeGray")
        </p>

        <p class="config_option">
            image_width<br/> image_height
        </p>

        <p>The width and height of the image in pixels. Optional. Default is 300 x 180 pixels.</p>

        <p class="config_option">show_daynight</p>

        <p>
            Set to <span class="code">true</span> to show day/night bands in an image. Otherwise, set to false. This
            only looks good with day or week plots. Optional. Default is <span class="code">false</span>.
        </p>

        <p class="config_option">skip_if_empty</p>

        <p>
            If set to <span class="code">true</span>, then skip the generation of the image if all data in it are null.
            If set to a time period, such as <span class="code">month</span> or <span class="code">year</span>, then
            skip the generation of the image if all data in that period are null. Default is <span
            class="code">false</span>.
        </p>

        <p class="config_option">stale_age</p>

        <p>
            Image file staleness age, in seconds. If the image file is older than this age it will be generated. If no
            <span class="code">stale_age</span> is specified, then the image file will be generated every time the
            generator runs.
        </p>

        <p class="config_option" id="imagegenerator-unit">unit</p>

        <p>
            Normally, the unit used in a plot is set by whatever <a href="#mixed_units">unit group the types are in</a>.
            However, this option allows overriding the unit used in a specific plot.
        </p>

        <h3>Various label options</h3>

        <p>These are options for the various labels used in the image.</p>

        <p class="config_option">axis_label_font_color</p>

        <p>
            The color of the x- and y-axis label font. Optional. Default is <span class='code'>black</span>.
        </p>

        <p class="config_option">axis_label_font_path</p>

        <p>
            The path to the font to be use for the x- and y-axis labels. Optional. If not given, or if WeeWX cannot find
            the font, then the default PIL font will be used.
        </p>

        <p class="config_option">axis_label_font_size</p>

        <p>
            The size of the x- and y-axis labels in pixels. Optional. The default is <span class='code'>10</span>.
        </p>

        <p class="config_option">bottom_label_font_color</p>

        <p>
            The color of the bottom label font. Optional. Default is <span class='code'>black</span>.
        </p>

        <p class="config_option">bottom_label_font_path</p>

        <p>
            The path to the font to be use for the bottom label. Optional. If not given, or if WeeWX cannot find the
            font, then the default PIL font will be used.
        </p>

        <p class="config_option">bottom_label_font_size</p>

        <p>
            The size of the bottom label in pixels. Optional. The default is <span class='code'>10</span>.
        </p>

        <p class="config_option">bottom_label_format</p>

        <p>
            The format to be used for the bottom label. It should be a <a
            href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior"> strftime format</a>.
            Optional. Default is <span class="code">'%m/%d/%y
          %H:%M'</span>.
        </p>

        <p class="config_option">bottom_label_offset</p>

        <p>The margin of the bottom label from the bottom of the plot. Default is 3.</p>

        <p class="config_option">top_label_font_path</p>

        <p>
            The path to the font to be use for the top label. Optional. If not given, or if WeeWX cannot find the font,
            then the default PIL font will be used.
        </p>

        <p class="config_option">top_label_font_size</p>

        <p>
            The size of the top label in pixels. Optional. The default is <span class='code'>10</span>.
        </p>

        <p class="config_option">unit_label_font_color</p>

        <p>
            The color of the unit label font. Optional. Default is <span class='code'>black</span>.
        </p>

        <p class="config_option">unit_label_font_path</p>

        <p>
            The path to the font to be use for the unit label. Optional. If not given, or if WeeWX cannot find the font,
            then the default PIL font will be used.
        </p>

        <p class="config_option">unit_label_font_size</p>

        <p>
            The size of the unit label in pixels. Optional. The default is <span class='code'>10</span>.
        </p>

        <p class="config_option">x_interval</p>

        <p>
            The time interval in seconds between x-axis tick marks. Optional. If not given, a suitable default will be
            chosen.
        </p>

        <p class="config_option">x_label_format</p>

        <p>
            The format to be used for the time labels on the x-axis. It should be a <a
            href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior"> strftime format</a>.
            Optional. If not given, a sensible format will be chosen automatically.
        </p>

        <p class="config_option">x_label_spacing</p>

        <p>
            Specifies the ordinal increment between labels on the x-axis: For example, 3 means a label every 3rd tick
            mark. Optional. The default is <span class='code'>2</span>.
        </p>

        <p class="config_option">y_label_side</p>

        <p>
            Specifies if the y-axis labels should be on the left, right, or both sides of the graph.
            Valid values are <span class='code'>left</span>, <span class='code'>right</span> or
            <span class='code'>both</span>.  Optional.  Default is <span class='code'>left</span>.
        </p>

        <p class="config_option">y_label_spacing</p>

        <p>
            Specifies the ordinal increment between labels on the y-axis: For example, 3 means a label every 3rd tick
            mark. Optional. The default is <span class='code'>2</span>.
        </p>

        <p class="config_option">y_nticks</p>

        <p>
            The nominal number of ticks along the y-axis. The default is <span class='code'>10</span>.
        </p>


        <h3>Plot scaling options</h3>

        <p class="config_option">time_length</p>

        <p>
            The nominal length of the time period to be covered in seconds. The exact length of the x-axis is chosen by
            the plotting engine to cover this period. Optional. Default is <span class="code">86400</span> (one day).
        </p>

        <p class="config_option">yscale</p>

        <p>
            A 3-way tuple (<span class="code">ylow</span>, <span class="code">yhigh</span>, <span class="code">min_interval</span>),
            where <span class="code">ylow</span> and <span class="code">yhigh</span> are the minimum and maximum y-axis
            values, respectively, and <span class="code">min_interval</span> is the minimum tick interval. If set to
            <span class="code">None</span>, the corresponding value will be automatically chosen. Optional. Default is
            <span class="code">None, None, None</span>. (Choose the y-axis minimum, maximum, and minimum increment
            automatically.)
        </p>


        <h3>Compass rose options</h3>

        <div class="image image-right" style="width: 300px">
            <img src="images/daywindvec.png" alt="Example of a progressive vector plot"/>

            <div class="image_caption">Example of a vector plot with a compass rose in the lower-left
            </div>
        </div>

        <p class="config_option">rose_label</p>

        <p>
            The label to be used in the compass rose to indicate due North. Optional. Default is <span
            class="code">N</span>.
        </p>

        <p class="config_option">rose_label_font_path</p>

        <p>
            The path to the font to be use for the rose label (the letter "N," indicating North). Optional. If not
            given, or if WeeWX cannot find the font, then the default PIL font will be used.
        </p>

        <p class="config_option">rose_label_font_size</p>

        <p>
            The size of the compass rose label in pixels. Optional. The default is <span class="code">10</span>.
        </p>

        <p class="config_option">rose_label_font_color</p>

        <p>The color of the compass rose label. Optional. Default is the same color as the rose itself.</p>

        <p class="config_option">vector_rotate</p>

        <p>
            Causes the vectors to be rotated by this many degrees. Positive is clockwise. If westerly winds dominate at
            your location (as they do at mine), then you may want to specify <span class="code">+90</span> for this
            option. This will cause the average vector to point straight up, rather than lie flat against the x-axis.
            Optional. The default is <span class='code'>0</span>.
        </p>


        <h3>Shared plot line options</h3>

        <p>These are options shared by all the plot lines.</p>

        <p class="config_option">chart_line_colors</p>

        <p>
            Each chart line is drawn in a different color. This option is a list of those colors. If the number of lines
            exceeds the length of the list, then the colors wrap around to the beginning of the list. Optional. In the
            case of bar charts, this is the color of the outline of the bar. Default is <span class="code">#0000ff, #00ff00, #ff0000</span>.
            <br/> <br/> Individual line color can be overridden by using option <span class="code">color</span>.
        </p>

        <p class="config_option">chart_fill_colors</p>

        <p>
            A list of the color to be used as the fill of the bar charts. Optional. The default is to use the same color
            as the outline color (option <span class="code">chart_line_colors</span>).
        </p>

        <p class="config_option">chart_line_width</p>

        <p>
            Each chart line can be drawn using a different line width. This option is a list of these widths. If the
            number of lines exceeds the length of the list, then the widths wrap around to the beginning of the list.
            Optional. Default is <span class="code">1, 1, 1</span>. <br/> <br/> Individual line widths can be overridden
            by using option <span class="code">width</span>.
        </p>


        <h3>Individual line options</h3>

        <p>These are options that are set for individual lines.</p>

        <p class="config_option">aggregate_interval</p>

        <p>
            The time period over which the data should be aggregated, in seconds. Required if
            <span class="code">aggregate_type</span> has been set. Alternatively, the time can be specified by using
            one of the "shortcuts" (that is, <span class="code">hour</span>, <span class="code">day</span>,
            <span class="code">week</span>, <span class="code">month</span>, or <span class="code">year</span>).
        </p>

        <p class="config_option">aggregate_type</p>

        <p>
            The default is to plot every data point, but this is probably not a good idea for any plot longer than a
            day. By setting this option, you can <em>aggregate</em> data by a set time interval. Available aggregation
            types include <span class="code">avg</span>, <span class="code">count</span>, <span
            class="code">cumulative</span>, <span class="code">diff</span>, <span class="code">last</span>, <span
            class="code">max</span>, <span class="code">min</span>, <span class="code">sum</span>, and <span
            class="code">tderiv</span>.
        </p>

        <p class="config_option">color</p>

        <p>
            This option is to override the color for an individual line. Optional. Default is to use the color in <span
            class="code">chart_line_colors</span>.
        </p>

        <p class="config_option">data_type</p>

        <p>
            The SQL data type to be used for this plot line. For more information, see the section <em><a
            href="#including_same_sql_type_2x">Including a type more than once in a plot</a></em>. Optional. The default
            is to use the section name.
        </p>

        <p class="config_option">fill_color</p>

        <p>
            This option is to override the fill color for a bar chart. Optional. Default is to use the color in <span
            class="code">chart_fill_colors</span>.
        </p>

        <p class="config_option">label</p>

        <p>The label to be used for this plot line in the top label. Optional. The default is to use the SQL variable
            name.
        </p>

        <p class="config_option">line_gap_fraction</p>

        <p>
            If there is a gap between data points bigger than this fractional amount of the x-axis, then a gap will be
            drawn, rather than a connecting line. See Section <em><a href="#line_gaps">Line gaps</a></em>. Optional. The
            default is to always draw the line.
        </p>

        <p class="config_option">line_type</p>

        <p>
            The type of line to be used. Choices are <span class="code">solid</span> or <span class="code">none</span>.
            Optional. Default is <span class="code">solid</span>.
        </p>

        <p class="config_option">marker_size</p>

        <p>
            The size of the marker. Optional. Default is <span class="code">8</span>.
        </p>

        <p class="config_option">marker_type</p>

        <p>
            The type of marker to be used to mark each data point. Choices are <span class="code">cross</span>, <span
            class="code">x</span>, <span class="code">circle</span>, <span class="code">box</span>, or <span
            class="code">none</span>. Optional. Default is <span class="code">none</span>.
        </p>

        <p class="config_option">plot_type</p>

        <p>
            The type of plot for this line. Choices are <span class="code">line</span>, <span class="code">bar</span>,
            or <span class="code">vector</span>. Optional. Default is <span class="code">line</span>.
        </p>

        <p class="config_option">width</p>

        <p>
            This option is to override the line widthfor an individual line. Optional. Default is to use the width in
            <span class="code">chart_line_width</span>.
        </p>


        <h2 class="config_section">[CopyGenerator]</h2>

        <p>
            This section is used by generator <span class="code">weewx.reportengine.CopyGenerator</span> and controls
            which files are to be copied over from the skin directory to the destination directory. Think of it as "file
            generation," except that rather than going through the template engine, the files are simply copied over.
        </p>

        <p class="config_option">copy_once</p>

        <p>This option controls which files get copied over on the first invocation of the report engine service.
            Typically, this is things such as style sheets or background GIFs. Wildcards can be used.
        </p>

        <p class="config_option">copy_always</p>

        <p>This is a list of files that should be copied on every invocation. Wildcards can be used.</p>

        <p>
            Here is the <span class="code">[CopyGenerator]</span> section from the Standard <span
            class="code">skin.conf</span>
        </p>
        <pre class="tty">[CopyGenerator]
    # This section is used by the generator CopyGenerator

    # List of files to be copied only the first time the generator runs
    copy_once = backgrounds/*, weewx.css, mobile.css, favicon.ico

    # List of files to be copied each time the generator runs
    # copy_always = </pre>
        <p>The Standard skin includes some background images, CSS files, and icons that need to be copied once. There
            are no files that need to be copied every time the generator runs.
        </p>


        <h2 class="config_section" id="generators_section">[Generators]</h2>

        <p>This section defines the list of generators that should be run.</p>

        <p class="config_option">generator_list</p>

        <p>This option controls which generators get run for this skin. It is a comma separated list. The generators
            will be run in this order.
        </p>

        <p>
            Here is the <span class="code">[Generators]</span> section from the Standard <span
            class="code">skin.conf</span>
        </p>
        <pre class="tty">[Generators]
    generator_list = weewx.cheetahgenerator.CheetahGenerator, weewx.imagegenerator.ImageGenerator, weewx.reportengine.CopyGenerator</pre>
        <p>The Standard skin uses three generators: CheetahGenerator, ImageGenerator, and CopyGenerator.</p>


        <!-- -------------------------------------------------------------- -->

        <h1>Appendix</h1>

        <h2 id="aggregation_types">Aggregation types</h2>

        <table class="indent">
            <caption>Aggregation types</caption>
            <tbody>
            <tr class="first_row">
                <td>Aggregation type</td>
                <td>Meaning</td>
            </tr>
            <tr>
                <td class="first_col code">avg</td>
                <td>The average value in the aggregation period.</td>
            </tr>
            <tr>
                <td class="first_col code">avg_ge(val)</td>
                <td>The number of days where the average value is greater than or equal to <em>val</em>. Aggregation
                    period must be one day or longer. The argument <span class="code">val</span> is a
                    <a href="#ValueTuple"><span class="code">ValueTuple</span></a>.
                </td>
            </tr>
            <tr>
                <td class="first_col code">avg_le(val)</td>
                <td>The number of days where the average value is less than or equal to <em>val</em>. Aggregation period
                    must be one day or longer. The argument <span class="code">val</span> is a
                    <a href="#ValueTuple"><span class="code">ValueTuple</span></a>.
                </td>
            </tr>
            <tr>
                <td class="first_col code">count</td>
                <td>The number of non-null values in the aggregation period.
                </td>
            </tr>
            <tr>
                <td class="first_col code">diff</td>
                <td>The difference between the last and first value in the aggregation period.
                </td>
            </tr>
            <tr>
                <td class="first_col code">exists</td>
                <td>Returns <span class="code">True</span> if the observation type exists in the database.</td>
            </tr>
            <tr>
                <td class="first_col code">first</td>
                <td>The first non-null value in the aggregation period.</td>
            </tr>
            <tr>
                <td class="first_col code">firsttime</td>
                <td>The time of the first non-null value in the aggregation period.
                </td>
            </tr>
            <tr>
                <td class="first_col code">gustdir</td>
                <td>The direction of the max gust in the aggregation period.
                </td>
            </tr>
            <tr>
                <td class="first_col code">has_data</td>
                <td>Returns <span class="code">True</span> if the observation type exists in the database and is
                    non-null.
                </td>
            </tr>
            <tr>
                <td class="first_col code">last</td>
                <td>The last non-null value in the aggregation period.</td>
            </tr>
            <tr>
                <td class="first_col code">lasttime</td>
                <td>The time of the last non-null value in the aggregation period.
                </td>
            </tr>
            <tr>
                <td class="first_col code">max</td>
                <td>The maximum value in the aggregation period.</td>
            </tr>
            <tr>
                <td class="first_col code">maxmin</td>
                <td>The maximum daily minimum in the aggregation period. Aggregation period must be one day or longer.
                </td>
            </tr>
            <tr>
                <td class="first_col code">maxmintime</td>
                <td>The time of the maximum daily minimum.</td>
            </tr>
            <tr>
                <td class="first_col code">maxsum</td>
                <td>The maximum daily sum in the aggregation period. Aggregation period must be one day or longer.
                </td>
            </tr>
            <tr>
                <td class="first_col code">maxsumtime</td>
                <td>The time of the maximum daily sum.</td>
            </tr>
            <tr>
                <td class="first_col code">maxtime</td>
                <td>The time of the maximum value.</td>
            </tr>
            <tr>
                <td class="first_col code">max_ge(val)</td>
                <td>The number of days where the maximum value is greater than or equal to <em>val</em>. Aggregation
                    period must be one day or longer. The argument <span class="code">val</span> is a
                    <a href="#ValueTuple"><span class="code">ValueTuple</span></a>.
                </td>
            </tr>
            <tr>
                <td class="first_col code">max_le(val)</td>
                <td>The number of days where the maximum value is less than or equal to <em>val</em>. Aggregation period
                    must be one day or longer. The argument <span class="code">val</span> is a
                    <a href="#ValueTuple"><span class="code">ValueTuple</span></a>.
                </td>
            </tr>
            <tr>
                <td class="first_col code">meanmax</td>
                <td>The average daily maximum in the aggregation period. Aggregation period must be one day or longer.
                </td>
            </tr>
            <tr>
                <td class="first_col code">meanmin</td>
                <td>The average daily minimum in the aggregation period. Aggregation period must be one day or longer.
                </td>
            </tr>
            <tr>
                <td class="first_col code">min</td>
                <td>The minimum value in the aggregation period.</td>
            </tr>
            <tr>
                <td class="first_col code">minmax</td>
                <td>The minimum daily maximum in the aggregation period. Aggregation period must be one day or longer.
                </td>
            </tr>
            <tr>
                <td class="first_col code">minmaxtime</td>
                <td>The time of the minimum daily maximum.</td>
            </tr>
            <tr>
                <td class="first_col code">minsum</td>
                <td>The minimum daily sum in the aggregation period. Aggregation period must be one day or longer.
                </td>
            </tr>
            <tr>
                <td class="first_col code">minsumtime</td>
                <td>The time of the minimum daily sum.</td>
            </tr>
            <tr>
                <td class="first_col code">mintime</td>
                <td>The time of the minimum value.</td>
            </tr>
            <tr>
                <td class="first_col code">min_ge(val)</td>
                <td>The number of days where the minimum value is greater than or equal to <em>val</em>. Aggregation
                    period must be one day or longer. The argument <span class="code">val</span> is a
                    <a href="#ValueTuple"><span class="code">ValueTuple</span></a>.
                </td>
            </tr>
            <tr>
                <td class="first_col code">min_le(val)</td>
                <td>The number of days where the minimum value is less than or equal to <em>val</em>. Aggregation period
                    must be one day or longer. The argument <span class="code">val</span> is a
                    <a href="#ValueTuple"><span class="code">ValueTuple</span></a>.
                </td>
            </tr>
            <tr>
                <td class="first_col code">not_null</td>
                <td>
                    Returns truthy if any value over the aggregation period is non-null.
                </td>
            </tr>
            <tr>
                <td class="first_col code">rms</td>
                <td>The root mean square value in the aggregation period.
                </td>
            </tr>
            <tr>
                <td class="first_col code">sum</td>
                <td>The sum of values in the aggregation period.</td>
            </tr>
            <tr>
                <td class="first_col code">sum_ge(val)</td>
                <td>The number of days where the sum of value is greater than or equal to <em>val</em>. Aggregation
                    period must be one day or longer. The argument <span class="code">val</span> is a
                    <a href="#ValueTuple"><span class="code">ValueTuple</span></a>.
                </td>
            </tr>
            <tr>
                <td class="first_col code">sum_le(val)</td>
                <td>The number of days where the sum of value is less than or equal to <em>val</em>. Aggregation period
                    must be one day or longer. The argument <span class="code">val</span> is a
                    <a href="#ValueTuple"><span class="code">ValueTuple</span></a>.
                </td>
            </tr>
            <tr>
                <td class="first_col code">tderiv</td>
                <td>
                    The time derivative between the last and first value in the aggregation period. This is the
                    difference in value divided by the difference in time.
                </td>
            </tr>
            <tr>
                <td class="first_col code">vecavg</td>
                <td>The vector average speed in the aggregation period.</td>
            </tr>
            <tr>
                <td class="first_col code">vecdir</td>
                <td>The vector averaged direction during the aggregation period.
                </td>
            </tr>
            </tbody>
        </table>

        <!-- -------------------------------------------------------------- -->

        <h2 id="units">Units</h2>

        <p>
            WeeWX offers three different <em>unit systems</em>:
        </p>

        <table class="indent" style="width: 80%">
            <caption>The standard unit systems used within WeeWX</caption>
            <tr class="first_row">
                <td>Name</td>
                <td>Encoded value</td>
                <td>Note</td>
            </tr>
            <tr>
                <td class="first_col code">US</td>
                <td>0x01</td>
                <td>U.S. Customary</td>
            </tr>
            <tr>
                <td class="first_col code">METRICWX</td>
                <td>0x11</td>
                <td>Metric, with rain related measurements in <span class="code">mm</span> and speeds in <span
                    class="code">m/s</span>
                </td>
            </tr>
            <tr>
                <td class="first_col code">METRIC</td>
                <td>0x10</td>
                <td>Metric, with rain related measurements in <span class="code">cm</span> and speeds in <span
                    class="code">km/hr</span>
                </td>
            </tr>
        </table>

        <p>The table below lists all the unit groups, their members, which units are options for the group, and what the
            defaults are for each standard unit system.
        </p>
        <table class="indent">
            <caption>Unit groups, members and options</caption>
            <tbody class="code">
            <tr class="first_row">
                <td>Group</td>
                <td>Members</td>
                <td>Unit options</td>
                <td><span class="code">US</span></td>
                <td><span class="code">METRICWX</span></td>
                <td><span class="code">METRIC</span></td>
            </tr>
            <tr>
                <td class="first_col">group_altitude</td>
                <td>altitude<br/> cloudbase
                </td>
                <td>foot <br/> meter
                </td>
                <td>foot</td>
                <td>meter</td>
                <td>meter</td>
            </tr>
            <tr>
                <td class="first_col">group_amp</td>
                <td></td>
                <td>amp</td>
                <td>amp</td>
                <td>amp</td>
                <td>amp</td>
            </tr>
            <tr>
                <td class="first_col">group_boolean</td>
                <td></td>
                <td>boolean</td>
                <td>boolean</td>
                <td>boolean</td>
                <td>boolean</td>
            </tr>
            <tr>
                <td class="first_col">group_concentration</td>
                <td>no2<br/>pm1_0<br/>pm2_5<br/>pm10_0</td>
                <td>microgram_per_meter_cubed</td>
                <td>microgram_per_meter_cubed</td>
                <td>microgram_per_meter_cubed</td>
                <td>microgram_per_meter_cubed</td>
            </tr>
            <tr>
                <td class="first_col">group_count</td>
                <td>leafWet1<br/>leafWet2<br/>lightning_disturber_count<br/>lightning_noise_count<br/>lightning_strike_count<br/></td>
                <td>count</td>
                <td>count</td>
                <td>count</td>
                <td>count</td>
            </tr>
            <tr>
                <td class="first_col">group_data</td>
                <td></td>
                <td>byte<br/> bit</td>
                <td>byte</td>
                <td>byte</td>
                <td>byte</td>
            </tr>
            <tr>
                <td class="first_col">group_db</td>
                <td>noise</td>
                <td>dB</td>
                <td>dB</td>
                <td>dB</td>
                <td>dB</td>
            </tr>
            <tr>
                <td class="first_col">group_delta_time</td>
                <td>daySunshineDur<br/>rainDur<br/>sunshineDurDoc</td>
                <td>second<br/> minute<br/>hour<br/>day<br/></td>
                <td>second</td>
                <td>second</td>
                <td>second</td>
            </tr>
            <tr>
                <td class="first_col">group_degree_day</td>
                <td>cooldeg<br/> heatdeg<br/> growdeg
                </td>
                <td>degree_F_day<br/> degree_C_day</td>
                <td>degree_F_day</td>
                <td>degree_C_day</td>
                <td>degree_C_day</td>
            </tr>
            <tr>
                <td class="first_col">group_direction</td>
                <td>gustdir <br/> vecdir <br/> windDir <br/> windGustDir</td>
                <td>degree_compass</td>
                <td>degree_compass</td>
                <td>degree_compass</td>
                <td>degree_compass</td>
            </tr>
            <tr>
                <td class="first_col">group_distance</td>
                <td>windrun<br/>lightning_distance</td>
                <td>mile<br/>km</td>
                <td>mile</td>
                <td>km</td>
                <td>km</td>
            </tr>
            <tr>
                <td class="first_col">group_energy</td>
                <td></td>
                <td>kilowatt_hour<br/>mega_joule<br/>watt_hour<br/>watt_second</td>
                <td>watt_hour</td>
                <td>watt_hour</td>
                <td>watt_hour</td>
            </tr>
            <tr>
                <td class="first_col">group_energy2</td>
                <td></td>
                <td>kilowatt_hour<br/>watt_hour<br/>watt_second</td>
                <td>watt_second</td>
                <td>watt_second</td>
                <td>watt_second</td>
            </tr>
            <tr>
                <td class="first_col">group_fraction</td>
                <td>co<br/>co2<br/>nh3<br/>o3<br/>pb<br/>so2</td>
                <td>ppm</td>
                <td>ppm</td>
                <td>ppm</td>
                <td>ppm</td>
            </tr>
            <tr>
                <td class="first_col">group_illuminance</td>
                <td>illuminance</td>
                <td>lux</td>
                <td>lux</td>
                <td>lux</td>
                <td>lux</td>
            </tr>
            <tr>
                <td class="first_col">group_interval</td>
                <td>interval</td>
                <td>minute</td>
                <td>minute</td>
                <td>minute</td>
                <td>minute</td>
            </tr>
            <tr>
                <td class="first_col">group_length</td>
                <td></td>
                <td>inch<br/> cm
                </td>
                <td>inch</td>
                <td>cm</td>
                <td>cm</td>
            </tr>
            <tr>
                <td class="first_col">group_moisture</td>
                <td>soilMoist1 <br/> soilMoist2 <br/> soilMoist3 <br/> soilMoist4
                </td>
                <td>centibar</td>
                <td>centibar</td>
                <td>centibar</td>
                <td>centibar</td>
            </tr>
            <tr>
                <td class="first_col">group_percent</td>
                <td>
                    cloudcover<br/>extraHumid1 <br/> extraHumid2 <br/> inHumidity <br/> outHumidity <br/>pop<br/>
                    rxCheckPercent<br/>snowMoisture
                </td>
                <td>percent</td>
                <td>percent</td>
                <td>percent</td>
                <td>percent</td>
            </tr>
            <tr>
                <td class="first_col">group_power</td>
                <td></td>
                <td>kilowatt<br/>watt</td>
                <td>watt</td>
                <td>watt</td>
                <td>watt</td>
            </tr>
            <tr>
                <td class="first_col">group_pressure</td>
                <td>
                    barometer <br/> altimeter <br/> pressure
                </td>
                <td>
                    inHg<br/>mbar<br/>hPa<br/>kPa
                </td>
                <td>inHg</td>
                <td>mbar</td>
                <td>mbar</td>
            </tr>
            <tr>
                <td class="first_col">group_pressurerate</td>
                <td>
                    barometerRate <br/> altimeterRate <br/> pressureRate
                </td>
                <td>
                    inHg_per_hour <br/> mbar_per_hour <br/> hPa_per_hour <br/> kPa_per_hour
                </td>
                <td>inHg_per_hour</td>
                <td>mbar_per_hour</td>
                <td>mbar_per_hour</td>
            </tr>
            <tr>
                <td class="first_col">group_radiation</td>
                <td>maxSolarRad <br/> radiation</td>
                <td>watt_per_meter_squared</td>
                <td>watt_per_meter_squared</td>
                <td>watt_per_meter_squared</td>
                <td>watt_per_meter_squared</td>
            </tr>
            <tr>
                <td class="first_col">group_rain</td>
                <td>rain<br/>ET<br/>hail<br/>snowDepth<br/>snowRate</td>
                <td>inch <br/> cm <br/> mm
                </td>
                <td>inch</td>
                <td>mm</td>
                <td>cm</td>
            </tr>
            <tr>
                <td class="first_col">group_rainrate</td>
                <td>rainRate <br/> hailRate
                </td>
                <td>inch_per_hour <br/> cm_per_hour <br/> mm_per_hour
                </td>
                <td>inch_per_hour</td>
                <td>mm_per_hour</td>
                <td>cm_per_hour</td>
            </tr>
            <tr>
                <td class="first_col">group_speed</td>
                <td>wind <br/> windGust <br/> windSpeed <br/> windgustvec <br/> windvec
                </td>
                <td>mile_per_hour <br/> km_per_hour <br/> knot <br/> meter_per_second <br/> beaufort
                </td>
                <td>mile_per_hour</td>
                <td>meter_per_second</td>
                <td>km_per_hour</td>
            </tr>
            <tr>
                <td class="first_col">group_speed2</td>
                <td>rms <br/> vecavg
                </td>
                <td>mile_per_hour2 <br/> km_per_hour2 <br/> knot2 <br/> meter_per_second2
                </td>
                <td>mile_per_hour2</td>
                <td>meter_per_second2</td>
                <td>km_per_hour2</td>
            </tr>
            <tr>
                <td class="first_col">group_temperature</td>
                <td>appTemp <br/> dewpoint <br/> extraTemp1 <br/> extraTemp2 <br/> extraTemp3 <br/> heatindex <br/>
                    heatingTemp <br/> humidex <br/> inTemp <br/> leafTemp1 <br/> leafTemp2 <br/> outTemp <br/> soilTemp1
                    <br/> soilTemp2 <br/> soilTemp3 <br/> soilTemp4 <br/> windchill <br/> THSW
                </td>
                <td>degree_C<br/> degree_F <br/> degree_E<br/> degree_K
                </td>
                <td>degree_F</td>
                <td>degree_C</td>
                <td>degree_C</td>
            </tr>
            <tr>
                <td class="first_col">group_time</td>
                <td>dateTime</td>
                <td>unix_epoch <br/> dublin_jd
                </td>
                <td>unix_epoch</td>
                <td>unix_epoch</td>
                <td>unix_epoch</td>
            </tr>
            <tr>
                <td class="first_col">group_uv</td>
                <td>UV</td>
                <td>uv_index</td>
                <td>uv_index</td>
                <td>uv_index</td>
                <td>uv_index</td>
            </tr>
            <tr>
                <td class="first_col">group_volt</td>
                <td>consBatteryVoltage <br/> heatingVoltage <br/> referenceVoltage <br/> supplyVoltage
                </td>
                <td>volt</td>
                <td>volt</td>
                <td>volt</td>
                <td>volt</td>
            </tr>
            <tr>
                <td class="first_col">group_volume</td>
                <td></td>
                <td>cubic_foot<br/> gallon<br/> liter
                </td>
                <td>gallon</td>
                <td>liter</td>
                <td>liter</td>
            </tr>
            <tr>
                <td class="first_col">group_NONE</td>
                <td>NONE</td>
                <td>NONE</td>
                <td>NONE</td>
                <td>NONE</td>
                <td>NONE</td>
            </tr>
            </tbody>
        </table>

        <!-- -------------------------------------------------------------- -->

        <h2 id="ValueTuple">Class <span class="code">ValueTuple</span></h2>
        <p>
            A value, along with the unit it is in, can be represented by a 3-way tuple called a "value tuple". They are
            used throughout WeeWX. All WeeWX routines can accept a simple unadorned 3-way tuple as a value tuple, but
            they return the type <span class="code">ValueTuple</span>. It is useful because its contents can be accessed
            using named attributes. You can think of it as a unit-aware value, useful for converting to and from other
            units.
        </p>
        <p>
            The following attributes, and their index, are present:
        </p>
        <table>
            <tr class="first_row">
                <td>Index</td>
                <td>Attribute</td>
                <td>Meaning</td>
            </tr>
            <tr>
                <td>0</td>
                <td class="code">value</td>
                <td>The data value(s). Can be a series (e.g., <span class="code">[20.2, 23.2, ...]</span>) or a scalar
                    (e.g., <span class="code">20.2</span>)
                </td>
            </tr>
            <tr>
                <td>1</td>
                <td class="code">unit</td>
                <td>The unit it is in (<span class="code">"degree_C"</span>)</td>
            </tr>
            <tr>
                <td>2</td>
                <td class="code">group</td>
                <td>The unit group (<span class="code">"group_temperature"</span>)</td>
            </tr>
        </table>

        <p>
            It is valid to have a datum value of None.
        </p>

        <p>
            It is also valid to have a unit type of None (meaning there is no information about the unit the value is
            in). In this case, you won't be able to convert it to another unit.
        </p>
        <p>Here are some examples:</p>
        <pre class="tty">
from weewx.units import ValueTuple

freezing_vt = ValueTuple(0.0, "degree_C", "group_temperature")
body_temperature_vt = ValueTuple(98.6, "degree_F", group_temperature")
station_altitude_vt = ValueTuple(120.0, "meter", "group_altitude")
        </pre>

        <h2 id="ValueHelper">Class <span class="code">ValueHelper</span></h2>
        <p>
            Class <span class="code">ValueHelper</span> contains all the information necessary to do the proper
            formatting of a value, including a unit label.
        </p>

        <h4>Instance attribute</h4>
        <p class="code">ValueHelper.<b>value_t</b></p>
        <p class="indent">Returns the <span class="code">ValueTuple</span> instance held internally.</p>

        <h4>Instance methods</h4>
        <p class="code">ValueHelper.<b>__str__</b>()</p>
        <p class="indent">Formats the value as a string, including a unit label, and returns it.</p>

        <p class="code">
            ValueHelper.<b>format</b>(<em>format_string=None, None_string=None, add_label=True, localize=True</em>)
        </p>
        <div class="indent">
            <p>
                Format the value as a string, using various specified options, and return it. Unless otherwise
                specified, a label is included.
            </p>
            <p>
                <span class="code">format_string</span> A string to be used for formatting. It must include one, and
                only one, <a href="https://docs.python.org/3/library/string.html#formatspec">format specifier</a>.
            </p>
            <p>
                <span class="code">None_string</span> In the event of a value of Python None, this string will be
                substituted. If None, then a default string from <span class="code">skin.conf</span> will be used.
            </p>
            <p>
                <span class="code">add_label</span> If truthy, then an appropriate unit label will be attached.
                Otherwise, no label is attached.
            </p>
            <p>
                <span class="code">localize</span> If truthy, then the results will be localized. For example, in some
                locales, a comma will be used as the decimal specifier.
            </p>
        </div>

    </div>
    <!-- end id technical_content -->

    <div class="footer">
        <p class="copyright">
            &copy; <a href="copyright.htm">Copyright</a> Tom Keffer
        </p>
    </div>

</div>
<!-- end class main -->

</body>
</html>
